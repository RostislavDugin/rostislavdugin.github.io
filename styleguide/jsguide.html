<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Google JavaScript руководство по стилю</title>
    <link rel="stylesheet" href="javaguide.css" />
    <script src="include/styleguide.js"></script>
    <link rel="shortcut icon" href="https://www.google.com/favicon.ico" />
    <script src="include/jsguide.js"></script>
  </head>

  <body>
    <div id="content">
      <h1>Google JavaScript руководство по стилю</h1>
      <h2 id="about-translation">О переводе</h2>

      <p>
        Оригинальное руководство по стилю Вы можете найти по ссылке — <a href="https://google.github.io/styleguide/jsguide.html">Google JavaScript Style Guide</a>.<br>
        Репозиторий с кодом данного перевода находится здесь — <a href="https://github.com/RostislavDugin/rostislavdugin.github.io/tree/master/styleguide">Репозиторий перевода JS Style Guide</a>
      </p>

      <p>Если Вы нашли несоответствие, ошибку или неточность в переводе — все читатели данного перевода будут очень благодарны Вам за pull request с исправлением :).</p>
      <h2 id="introduction">1 Введение</h2>

      <p>
        Этот документ содержит <strong>полное</strong> описание стандартов
        Google для исходного кода на языке JavaScript. JavaScript файл считается
        написанным в <em>стиле Google</em>, если и только если он придерживается
        правил, описанных в этом документе.
      </p>

      <p>
        Как и другие руководства по стилю программирования, данный документ
        охватывает не только вопрос оформления и форматирования кода, но также
        включает соглашения и стандарты написания кода. Хотя документ
        фокусируется на основных быстро применимых правилах, которым в компании
        Google следуют повсеместно — здесь также описываются правила и советы,
        которым не следует следовать (как при ручном, так и при автоматическом
        написании кода).
      </p>

      <h3 id="terminology-notes">1.1 Терминологические примечания</h3>

      <p>В данном документе, если не указано другое:</p>

      <ol>
        <li>
          <p>
            Термин <em>комментарий</em> всегда относится к комментарию
            <em>реализации</em>. Мы не используем фразу
            <em>документирующий комментарий</em>. Для этого мы используем общий
            термин &#8220;JSDoc&#8221;, включая текст, читаемый человеком, и
            аннотации, обрабатывающиеся компьютером при помощи
            <code>/** &#8230; */</code>.
          </p>
        </li>
        <li>
          <p>
            Данное руководство по стилю ссылается на терминологию
            <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a>, когда
            использует фразы "нужно", "не нужно", "не стоит" и "вероятно".
            Термины "отдавайте предпочтение" и "избегайте" используются в смысле
            "стоит" и "не стоит" делать соответственно, но не являются
            обязательными правилами.
          </p>
        </li>
      </ol>

      <p>
        Другие <q>терминологические уточнения</q> будут иногда появляться по
        ходу документа.
      </p>

      <h3 id="guide-notes">1.2 Примечания по руководству</h3>

      <p>
        Примеры кода в этом документе не являются
        <strong>нормативными</strong> (т.е. обязательными). Это значит, что
        примеры в стиле Google могут и не иллюстрировать единственно правильный
        вариант стилизации кода. Форматирование кода в данном файле не должно
        приниматься в качестве правила.
      </p>

      <h2 id="source-file-basics">2 Основы исходных файлов</h2>
      <h3 id="file-name">2.1 Имя файла</h3>

      <p>
        Имена файлов должны быть в нижнем регистре и могут включать нижнее
        подчеркивание (<code>_</code>) или "тире" (<code>-</code>), но без любой
        другой пунктуации. Придерживайтесь договоренностей, которые используются
        в вашем проекте. Расширения файлов должны быть <code>.js</code>.
      </p>

      <h3 id="file-encoding">2.2 Кодировка файлов UTF-8</h3>

      <p>Кодировка файлов должна быть в <strong>UTF-8</strong>.</p>

      <h3 id="special-characters">2.3 Специальные символы</h3>
      <h4 id="whitespace-characters">2.3.1 Пробельные символы</h4>

      <p>
        Помимо последовательности символов перевода строки, символ
        горизонтального пробела (0х20) из таблицы символов ASCII — единственный
        допустимый символ пробела, который может появляться где-либо в исходном
        коде. Это подразумевает, что:
      </p>

      <ol>
        <li><p>Все другие пробельные символы экранируются.</p></li>
        <li>
          <p>
            Отступ с помощью Tab <strong>не</strong> используется для отступа.
          </p>
        </li>
      </ol>

      <h4 id="special-escape-sequences">
        2.3.2 Специальные экранирующие последовательности
      </h4>

      <p>
        Любые символы, которые требуется экранировать специальными символьными
        последовательностями (<code>\'</code>, <code>\"</code>, <code>\\</code>,
        <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>,
        <code>\t</code>, <code>\v</code>) — используют данные последовательности
        вместо числового экранирования (например, <code>\x0a</code>,
        <code>\u000a</code> или <code>\u{a}</code>). Устаревшие восьмеричные
        символы экранирования не используются.
      </p>

      <h4 id="non-ascii-characters">2.3.3 Не-ASCII символы</h4>

      <p>
        Для оставшихся не-ASCII символов используется или подходящий символ
        Unicode (например, <code>&#8734;</code>), или эквивалентная hex или
        Unicode последовательность символов (например, <code>\u221e</code>) в
        зависимости от того, что делает код более
        <strong>легко читаемым и более понятным</strong>.
      </p>

      <p>
        Подсказка: при использовании Unicode-символов (или их
        последовательностей), лучше использовать пояснительный комментарий.
      </p>

      <pre>
        <code class="language-js prettyprint">/* В идеале: код хорошо понятен даже без комментария. */
const units = '&#956;s';

/* Разрешено: но необязательно, так как &#956; — это печатаемый символ. */
const units = '\u03bcs'; // '&#956;s'

/* Хорошо: используется экранирование для непечатаемых символов с комментарием для большей ясности. */
return '\ufeff' + content;  // Добавляется знак "порядка байтов".</code></pre>
      <pre><code class="language-js prettyprint badcode">/* Плохо: читатель не понимает, что это за символ. */
const units = '\u03bcs';</code>
      </pre>

      <p>
        Подсказка: никогда не делайте Ваш код менее читабельным просто из-за
        страха, что некоторые программы могут некорректно обрабатывать не-ASCII
        символы. В случае, если это произойдет — программа будет "сломана" и это
        потребуется исправить (т.е. вы не упустите данный момент).
      </p>

      <h2 id="source-file-structure">3 Структура исходных файлов</h2>

      <p>
        Все новые файлы должны быть или файлом <code>goog.module</code> (файл
        содержащий вызов <code>goog.module</code>), или модулем ECMAScript
        (использует операторы <code>import</code> и <code>export</code>). Файлы
        состоят из следующего (по порядку):
      </p>

      <ol>
        <li>Информация о лицензии или авторских правах, если такие имеются</li>
        <li><code>@fileoverview</code> JSDoc, если имеется</li>
        <li>
          Оператор <code>goog.module</code>, если это
          <code>goog.module</code> файл
        </li>
        <li>ES оператор <code>import</code>, если это ES модуль</li>
        <li>
          Операторы <code>goog.require</code> и <code>goog.requireType</code>
        </li>
        <li>Реализация файла</li>
      </ol>

      <p>
        <strong>Только одна линия</strong> отделяет каждую секцию кода, за
        исключением отделения реализации файла, которая должна отделяться 1 или
        2 пустыми линиями.
      </p>

      <h3 id="file-copyright">
        3.1 Информация о лицензии или авторских правах, если имеется.
      </h3>

      <p>
        Если информация о лицензии или авторском праве находится в файле, она
        находится здесь.
      </p>

      <h3 id="file-fileoverview">
        3.2 <code>@fileoverview</code> JSDoc, если имеется
      </h3>

      <p>
        Смотрите <a href="#jsdoc-top-file-level-comments">??</a> о правилах
        форматирования.
      </p>

      <h3 id="file-goog-module">3.3 Оператор <code>goog.module</code></h3>

      <p>
        Все <code>goog.module</code> файлы должны объявлять только одно имя для
        <code>goog.module</code> в одном файле: линии, содержащие объявление
        <code>goog.module</code> не должны разрываться и, следовательно, они
        являются исключением из правила про лимит в 80 символов.
      </p>

      <p>
        Аргумент goog.module определяет пространство имен. Это имя пакета
        (идентификатор, который отражает фрагмент структуры каталогов, где
        находится исходный код) и, опционально, главный
        класс\перечисление\интерфейс, который определяет связь со всем модулем.
      </p>

      <p>Пример:</p>

      <pre>
        <code class="language-js prettyprint">goog.module('search.urlHistory.UrlHistoryService');</code>
      </pre>

      <h4 id="naming-hierarchy">3.3.1 Иерархия</h4>

      <p>
        Пространство имен модуля никогда не должно именоваться как прямой
        потомок другого пространства имен, принадлежащий другому модулю.
      </p>

      <p>Не разрешается:</p>

      <pre>
        <code class="language-js prettyprint badcode">goog.module('foo.bar');   // 'foo.bar.qux' было бы неплохо
goog.module('foo.bar.baz');</code>
      </pre>

      <p>
        Иерархия каталогов отражает иерархию пространств имен, поэтому более
        глубокие вложенные дочерние элементы являются подкаталогами родительских
        каталогов верхнего уровня. Обратите внимание, что владельцы
        &#8220;родительских&#8221; групп пространств имен обязательно знают обо
        всех дочерних пространствах имен, поскольку они существуют в одном и том
        же каталоге.
      </p>

      <h4 id="file-declare-legacy-namespace">
        3.3.2 <code>goog.module.declareLegacyNamespace</code>
      </h4>

      <p>
        Оператор <code>goog.module</code> может опционально следовать до вызова
        <code>goog.module.declareLegacyNamespace();</code>. Не используйте
        <code>goog.module.declareLegacyNamespace()</code>, когда это возможно.
      </p>

      <p>Пример:</p>

      <pre>
        <code class="language-js prettyprint">goog.module('my.test.helpers');
goog.module.declareLegacyNamespace();
goog.setTestOnly();</code>
      </pre>

      <p>
        <code>goog.module.declareLegacyNamespace</code> существует для
        облегчения перехода от традиционных пространств имен на основе иерархии
        объектов, но имеет некоторые ограничения в плане именования. Поскольку
        имя дочернего модуля должно быть создано после родительского
        пространства имен, это имя <strong>не должно быть</strong> дочерним или
        родительским по отношению к <code>goog.module</code> (например,
        <code>goog.module('parent');</code> и
        <code>goog.module('parent.child');</code> не могут существовать
        одновременно, так же как и не может <code>goog.module('parent');</code> и
        <code>goog.module('parent.child.grandchild');</code>).
      </p>

      <h3 id="file-goog-module-exports">
        3.3.3 <code>goog.module</code> Экспорт
      </h3>

      <p>
        Классы, перечисления, функции, константы и другие символы
        экспортируются, используя объект <code>exports</code>. Экспортируемые
        символы могут быть определены прямо в объекте <code>exports</code> или
         определяться локально, а потом экспортироваться раздельно. Символы
        экспортируются только тогда, когда они должны использоваться за
        пределами модуля. Не экспортируемые модульно-локальные символы не
        декларируются как <code>@private</code> и не заканчиваются нижней
        чертой. Определенного порядка для экспортируемых модульно-локальных
        символов — нет.
      </p>

      <p>Пример:</p>

      <pre>
        <code class="language-js prettyprint">const /** !Array&lt;number&gt; */ exportedArray = [1, 2, 3];

const /** !Array&lt;number&gt; */ moduleLocalArray = [4, 5, 6];

/** @return {number} */
function moduleLocalFunction() {
  return moduleLocalArray.length;
}

/** @return {number} */
function exportedFunction() {  
  return moduleLocalFunction() * 2;
}

exports = {exportedArray, exportedFunction};</code></pre>
      <pre><code class="language-js prettyprint">/** @const {number} */
exports.CONSTANT_ONE = 1;

/** @const {string} */
exports.CONSTANT_TWO = 'Другая константа';</code>
      </pre>

      <p>
        Не аннотируйте <code>exports</code> с помощью <code>@const</code>, так
        как они уже рассматриваются компилятором в качестве констант.
      </p>

      <pre>
        <code class="language-js badcode prettyprint">/** @const */
exports = {exportedFunction};</code>
      </pre>

      <p><span id="file-es6-modules"></span></p>

      <h3 id="file-es-modules">3.4 ES модули</h3>

      <p><span id="es6-module-imports"></span></p>

      <h4 id="es-module-imports">3.4.1 Импорт</h4>

      <p>
        Операторы импорта не должны разделяться переносом строки и,
        следовательно, являются исключением из ограничения в 80 символов.
      </p>

      <p><span id="es6-import-paths"></span></p>

      <h5 id="esm-import-paths">3.4.1.1 Импорт путей</h5>
      <p>
        Файлы ES модуля должны использовать оператор <code>import</code> для
        импорта файлов из ES модуля. Не используйте
        <code>goog.require</code> для импорта другого ES модуля.
      </p>

      <pre>
        <code class="language-js prettyprint external">import './sideeffects.js';
          
import * as goog from '../closure/goog/goog.js';
import * as parent from '../parent.js';

import {name} from './sibling.js';</code>
      </pre>

      <p><span id="es6-import-paths-file-extension"></span></p>

      <h6 id="esm-import-paths-file-extension">
        3.4.1.1.1 Расширения файлов в для импортируемых путей
      </h6>

      <p>
        Расширение <code>.js</code> не является опциональным в импортируемых
        путях и всегда должно присутствовать.
      </p>

      <pre><code class="language-js badcode prettyprint">import '../directory/file';</code></pre>
      <pre><code class="language-js good prettyprint">import '../directory/file.js';</code></pre>

      <h5 id="importing-the-same-file-multiple-times">
        3.4.1.2 Импорт одного файла несколько раз
      </h5>

      <p>
        Не импортируйте один и тот же файл несколько раз. Это может затруднить
        определение совокупности всех импортов в файле.
      </p>

      <pre>
        <code class="language-js badcode prettyprint">// Импорт имеет один и тот же путь, но, поскольку он не выравнивается, может быть трудно его заметить.
import {short} from './long/path/to/a/file.js';
import {aLongNameThatBreaksAlignment} from './long/path/to/a/file.js';</code>
      </pre>

      <p><span id="naming-es6-imports"></span></p>

      <h5 id="naming-esm-imports">3.4.1.3 Именование импортов</h5>

      <h6 id="naming-module-imports">
        3.4.1.3.1 Именование модульных импортов
      </h6>

      <p>
        Имена импорта модуля (<code>import * as name</code>) — это имена в
        <code>нижнемВерблюжьемСтиле</code>, которые получены из имени
        импортируемого файла.
      </p>

      <pre>
        <code class="language-js prettyprint">import * as fileOne from '../file-one.js';
import * as fileTwo from '../file_two.js';
import * as fileThree from '../filethree.js';</code>
      </pre>

      <pre>
        <code class="language-js prettyprint">import * as libString from './lib/string.js';
import * as math from './math/math.js';
import * as vectorMath from './vector/math.js';</code>
      </pre>

      <h6 id="naming-default-imports">
        3.4.1.3.2 Именование импортов по умолчанию
      </h6>

      <p>
        Имена импорта по умолчанию получаются из имени импортируемого файла и
        следуют правилам из <a href="#naming-rules-by-identifier-type">??</a>.
      </p>

      <pre>
        <code class="language-js prettyprint">import MyClass from '../my-class.js';
import myFunction from '../my_function.js';
import SOME_CONSTANT from '../someconstant.js';</code>
      </pre>

      <p>
        Примечание: В общем случае этого не должно происходить, поскольку
        экспорт по умолчанию запрещен этим руководством по стилю, см.
        <a href="#named-vs-default-exports">??</a>. Импорт по умолчанию
        используется только для импорта модулей, которые не соответствуют этому
        руководству по стилю.
      </p>

      <h6 id="naming-named-imports">
        3.4.1.3.3 Именование именованного импорта
      </h6>

      <p>
        В целом, символы, импортируемые через именованный импорт (<code
          >import {name}</code
        >), должны иметь одинаковое имя. Избегайте импорта псевдонимов (<code
          >import {SomeThing as SomeOtherThing}</code
        >). Отдавайте предпочтение исправлению конфликтов имен при помощи импорта
        модуля (<code>import *</code>) или переименовывая сами экспорты.
      </p>

      <pre>
        <code class="language-js prettyprint">import * as bigAnimals from './biganimals.js';
import * as domesticatedAnimals from './domesticatedanimals.js';

new bigAnimals.Cat();
new domesticatedAnimals.Cat();</code>
      </pre>

      <p>
        Если необходимо переименовать именованный импорт, используйте компоненты
        имени файла или путь в полученном псевдониме.
      </p>

      <pre>
        <code class="language-js prettyprint">import {Cat as BigCat} from './biganimals.js';
import {Cat as DomesticatedCat} from './domesticatedanimals.js';

new BigCat();
new DomesticatedCat();</code>
      </pre>

      <p><span id="es6-module-exports"></span></p>

      <h4 id="es-module-exports">3.4.2 Экспорт</h4>
      <p>
        Символы экспортируются только в том случае, если они предназначены для
        использования вне модуля. Неэкспортированные локальные символы не
        объявляются как <code>@private</code>, и их имена не заканчиваются
        подчеркиванием. Не существует предписанного порядка для экспортируемых и
        локальных символов.
      </p>

      <h5 id="named-vs-default-exports">
        3.4.2.1 Именованный экспорт vs экспорт по умолчанию
      </h5>

      <p>
        Используйте именованный экспорт во всем коде. Вы можете применить
        ключевое слово <code>export</code> в объявлении или использовать
        синтаксис <code>export {name};</code>.
      </p>

      <p>
        Не используйте экспорт по умолчанию. Импортирующие модули должны давать
        имя этим значениям, чтобы избежать несоответствий в именах модулей.
      </p>

      <pre>
        <code class="language-js badcode prettyprint">// Не используйте экспорт по умолчанию:
export default class Foo { ... } // Плохо!</code>
      </pre>

      <pre>
        <code class="language-js good prettyprint">// Используйте именованный экспорт:
export class Foo { ... }</code>
      </pre>

      <pre>
        <code class="language-js good prettyprint">// Альтернативный стиль с именем экспорта:
class Foo { ... }

export {Foo};</code>
      </pre>

      <h5 id="exporting-static-containers">
        3.4.2.2 Экспорт статических контейнерных классов и объектов
      </h5>

      <p>
        Не экспортируйте классы контейнеров или объекты со статическими методами
        или свойствами для пространства имен.
      </p>

      <pre>
        <code class="language-js badcode prettyprint">// container.js
// Плохо: контейнер — это экспортируемый класс, который имеет только статические методы и поля.
export class Container {
  /** @return {number} */
  static bar() {
    return 1;
  }
}

/** @const {number} */
Container.FOO = 1;</code>
      </pre>

      <p>Вместо этого экспортируйте отдельные константы и функции:</p>

      <pre>
        <code class="language-js good prettyprint">/** @return {number} */
export function bar() {
  return 1;
}

export const /** number */ FOO = 1;</code>
      </pre>

      <p><span id="es6-exports-mutability"></span></p>

      <h5 id="esm-exports-mutability">3.4.2.3 Мутабельность экспорта</h5>

      <p>
        Экспортируемые переменные не должны быть видоизменены за пределами
        инициализации модуля.
      </p>

      <p>
        Существуют альтернативы, если необходимо изменения, включая экспорт
        постоянной ссылки на объект, который имеет изменяемые поля или экспорт
        функций доступа для изменяемых данных.
      </p>

      <pre><code class="language-js badcode prettyprint">// Плохо: и foо, и mutateFoo экспортируются и могут быть изменены.
export let /** number */ foo = 0;

/**
 * Изменяется foo. 
 */
 export function mutateFoo() {
  ++foo;
}

/**
 * @param {function(number): number} newMutateFoo 
 */
 export function setMutateFoo(newMutateFoo) {
  // Экспортируемые классы и функции могут быть видоизменены!
  mutateFoo = () =&gt; {
    foo = newMutateFoo(foo);  
  };
}</code>
      </pre>

      <pre>
        <code class="language-js good prettyprint">// Хорошо: вместо того, чтобы экспортировать изменяемые переменные foo и mutateFoo напрямую,
// вместо этого сделайте их модульными и экспортируйте getter для foo и оболочку для
// mutateFooFunc.
let /** number */ foo = 0;
let /** function(number): number */ mutateFooFunc = foo =&gt; foo + 1;

/** @return {number} */
export function getFoo() {
  return foo;
}

export function mutateFoo() {
  foo = mutateFooFunc(foo);
}

/** @param {function(number): number} mutateFoo */
export function setMutateFoo(mutateFoo) {
  mutateFooFunc = mutateFoo;
}</code>
      </pre>

      <p><span id="es6-module-circular-dependencies"></span></p>
      <h5 id="es-module-export-from">3.4.2.4 export from</h5>

      <p>
        Операторы <code>export from</code> не должны быть перенесены на другую
        строку и, следовательно, являются исключением из ограничения в 80
        символом. Это относится ко всем <code>export from</code> операторам.
      </p>

      <pre>
        <code class="language-js">export {specificName} from './other.js';
export * from './another.js';</code>
      </pre>

      <h4 id="es-module-circular-dependencies">
        3.4.3 Циклические зависимости в ES модулях
      </h4>

      <p>
        Не создавайте циклы между модулями ES, даже если спецификация ECMAScript
        позволяет это. Обратите внимание, что можно создавать циклы как с
        помощью операторов <code>import</code>, так и <code>export</code>.
      </p>

      <pre>
        <code class="language-js badcode prettyprint">// a.js
import './b.js';</code>
      </pre>

      <pre>
        <code class="language-js badcode prettyprint">// b.js
import './a.js';

// `export from` тоже может вызвать циклические зависимости!
export {x} from './c.js';</code>
      </pre>

      <pre>
        <code class="language-js badcode prettyprint">// c.js
import './b.js';

export let x;</code>
      </pre>

      <p><span id="es6-module-closure-interop"></span></p>
      <h4 id="es-module-closure-interop">3.4.4 Взаимодействие с Closure</h4>

      <p><span id="es6-module-referencing-goog"></span></p>
      <h5 id="es-module-referencing-goog">3.4.4.1 Ссылка на goog</h5>

      <p>
        Для того, чтобы сослаться на пространство имён Closure
        <code>goog</code>, импортируйте <code>goog.js</code> из Closure.
      </p>

      <pre>
        <code class="language-js good prettyprint external">import * as goog from '../closure/goog/goog.js';

const name = goog.require('a.name');

export const CONSTANT = name.compute();</code>
      </pre>

      <p>
        <code>goog.js</code> экспортирует только подмножество параметров из
        глобального <code>goog</code>, которые могут использоваться в ES
        модулях.
      </p>

      <p><span id="goog-require-in-es6-module"></span></p>
      <h5 id="goog-require-in-es-module">3.4.4.2 goog.require в ES модулях</h5>

      <p>
        <code>goog.require</code> в ES модулях работает так же, как и в
        <code>goog.module</code> файлах. Вы можете потребовать (require) любой
        символ пространства имён из Closure (т.е. символы, созданные с помощью
        <code>goog.provide</code> или <code>goog.module</code>), и
        <code>goog.require</code> вернёт значение.
      </p>

      <pre>
        <code class="language-js prettyprint external">import * as goog from '../closure/goog/goog.js';
import * as anEsModule from './anEsModule.js';

const GoogPromise = goog.require('goog.Promise');
const myNamespace = goog.require('my.namespace');</code>
      </pre>

      <p><span id="closure-module-id-in-es6-module"></span></p>

      <h5 id="closure-module-id-in-es-module">
        3.4.4.3 Декларирование Closure ID модулей в ES модулях
      </h5>

      <p>
        <code>goog.declareModuleId</code> может использоваться в ES модулях,
        чтобы декларировать ID модуля в стиле <code>goog.module</code>. Это
        значит, что ID модуля может быть потребован с помощью
        <code>goog.require</code>, <code>goog.module.get</code>,
        <code>goog.forwardDeclare</code> и т.п., как будто это
        <code>goog.module</code>, который не вызывает
        <code>goog.module.declareLegacyNamespace</code>. Это не делает ID модуля
        глобально доступным JavaScript символом.
      </p>

      <p>
        <code>goog.require</code> (или <code>goog.module.get</code>) примененный
        для ID модуля из <code>goog.declareModuleId</code> — будет всегда
        возвращать объект модуля (как будто используется <code>import *</code>).
        Как результат, аргумент для <code>goog.declareModuleId</code> должен
        всегда заканчиваться <code>именемНижнегоРегистра</code>.
      </p>

      <p>
        Обратите внимание: ошибка — вызывать
        <code>goog.module.declareLegacyNamespace</code> в ES модуле, он может
        быть вызван только из файлов <code>goog.module</code>. Не существует
        прямых путей, чтобы ассоциировать <q>устаревшее</q> пространство имён с
        ES модулем.
      </p>

      <p>
        <code>goog.declareModuleId</code> должен использоваться только для того,
        чтобы обновить Closure файлы в месте, где используется именованный
        экспорт.
      </p>

      <pre>
        <code class="language-js prettyprint external">import * as goog from '../closure/goog.js';
goog.declareModuleId('my.esm');
export class Class {};</code>
      </pre>

      <h3 id="file-set-test-only">3.5 <code>goog.setTestOnly</code></h3>

      <p>
        В файле модуля <code>goog.module</code> оператор
        <code>goog.module</code> может опционально сопровождаться вызовом
        <code>goog.setTestOnly()</code>.
      </p>

      <p>
        В ES модуле оператор <code>import</code> может опционально
        сопровождаться вызовом <code>goog.setTestOnly()</code>.
      </p>

      <h3 id="file-goog-require">
        3.6 Операторы <code>goog.require</code> и <code>goog.requireType</code>
      </h3>

      <p>
        Импорты, реализованные с помощью операторов <code>goog.require</code> и
        <code>goog.requireType</code>. Имена, импортированные с помощью оператора
        <code>goog.require</code>, могут быть использованы и в коде, и в
        аннотациях, в то время как импортированные с помощью
        <code>goog.requireType</code> могут быть использованы в аннотациях
        типа.
      </p>

      <p>
        Операторы <code>goog.require</code> и
        <code>goog.requireType</code> формируют единый блок без пустых линий
        внутри. Этот блок следует за декларацией <code>goog.module</code>,
        разделённой
        <a href="#source-file-structure">с помощью одной пустой линии</a>.
        Единственный аргумент для <code>goog.require</code> или
        <code>goog.requireType</code> — это пространство имен, определенное с
        помощью <code>goog.module</code> в отдельном файле. Операторы
        <code>goog.require</code> и <code>goog.requireType</code> не должны
        появляться в других местах данного файла.
      </p>

      <p>
        Каждый <code>goog.require</code> или
        <code>goog.requireType</code> определяется в виде отдельного
        константного псевдонима или деструктурируется в несколько константных
        псевдонимов. Эти псевдонимы - единственный допустимый способ сослаться на
        зависимости в коде или аннотациях типа. Полные имена пространства имен
        не должны использоваться нигде, кроме как в качестве аргумента для
        <code>goog.require</code> или <code>goog.requireType</code>.
      </p>

      <p>
        <strong>Исключение</strong>: Типы, переменные, и функции определенные во
        внешних файлах вынуждены использовать их полные имена в аннотациях и
        коде.
      </p>
      <p>
        Псевдонимы должны соответствовать финальному компоненту, разделенному
        точками, из модульного пространства имен.
      </p>
      <p>
        <strong>Исключение</strong>: В некоторых случаях, дополнительные
        компоненты пространства имен могут использоваться для формирования более
        длинных псевдонимов. Полученный псевдоним должен сохранять регистр
        исходного идентификатора, чтобы он по-прежнему правильно идентифицировал
        свой тип. Более длинные псевдонимы могут использоваться для устранения
        неоднозначности идентичных псевдонимов, или если это значительно улучшает
        читабельность. Кроме того, для предотвращения маскирования нативных
        типов, таких как <code>Element</code>, <code>Event</code>,
        <code>Error</code>, <code>Map</code> и <code>Promise</code> (см. более
        полный список в
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects"
          >Стандартные встроенные объекты</a
        >
        и MDN
        <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web APIs</a>). При переименовании деструктурированных псевдонимов пробел должен
        следовать за двоеточием, как требуется в
        <a href="#formatting-horizontal-whitespace">??</a>.
      </p>

      <p>
        Файл не должен содержать оба оператора <code>goog.require</code> и
        <code>goog.requireType</code> для одного и того же пространства имен.
        Если импортированное имя используется как в коде, так и в аннотациях
        типа, оно должно быть импортировано одним оператором
        <code>goog.require</code>.
      </p>

      <p>
        Если модуль импортируется только для его побочных эффектов, вызов должен
        быть сделан при помощи <code>goog.require</code> (а не
        <code>goog.requireType</code>), а назначение может быть опущено. Также
        необходим комментарий, чтобы объяснить, почему это необходимо, и
        подавить предупреждение компилятора.
      </p>

      <p>
        Строки сортируются в соответствии со следующими правилами: Все
        <code>require</code> с именем слева идут на первом месте,
        отсортированными по алфавиту. Затем <code>require</code> с
        деструктуризацией, снова отсортированные по названиям слева. Наконец,
        любые вызовы <code>require</code>, которые являются автономными (обычно
        модули, импортированные только для побочных эффектов).
      </p>

      <p>
        Совет: Нет необходимости запоминать этот порядок и применять его
        вручную. Вы можете положиться на свою среду IDE, чтобы сообщить о
        <code>require</code>, которые отсортированы неправильно.
      </p>

      <p>
        Если длинный псевдоним или имя модуля приведет к тому, что строка
        превысит ограничение в 80 символов, оно <strong>не</strong> должно
        переноситься: строки с <code>require</code> являются исключением из
        ограничения в 80 столбцов.
      </p>

      <p>Пример:</p>

      <pre>
        <code class="language-js prettyprint">// Стандартный стиль псевдонимов.
const MyClass = goog.require('some.package.MyClass');
const MyType = goog.requireType('some.package.MyType');
// Псевдоним на основе пространства имен, используемый для устранения неоднозначности.
const NsMyClass = goog.require('other.ns.MyClass');
// Псевдоним на основе пространства имен, используемый для предотвращения маскирования собственного типа.
const RendererElement = goog.require('web.renderer.Element');
// Непоследовательные псевдонимы на основе пространства имен используются для улучшения читабельности.
// Кроме того, строки, содержащие более 80 столбцов, не должны переноситься.
const SomeDataStructureModel = goog.requireType('identical.package.identifiers.models.SomeDataStructure');
const SomeDataStructureProto = goog.require('proto.identical.package.identifiers.SomeDataStructure');
// Стандартный стиль псевдонима.
const asserts = goog.require('goog.asserts');
// Псевдоним на основе пространства имен, используемый для устранения неоднозначности.
const testingAsserts = goog.require('goog.testing.asserts');
// Стандартная деструктуризация в псевдонимы.
const {clear, clone} = goog.require('goog.array');
const {Rgb} = goog.require('goog.color');
// Деструктуризация на основе пространства имен в псевдонимы для устранения неоднозначности.
const {SomeType: FooSomeType} = goog.requireType('foo.types');
const {clear: objectClear, clone: objectClone} = goog.require('goog.object');
// goog.require без псевдонима, чтобы вызвать побочные эффекты.
/** @suppress {extraRequire} Инициализируется MyFramework. */
goog.require('my.framework.initialization');</code>
      </pre>

      <p>Неоднозначно:</p>
      <pre>
<code class="language-js badcode prettyprint">// Если необходимо устранить неоднозначность, предпочтите PackageClass, а не SomeClass,
// так как он ближе к формату имени модуля.
const SomeClass = goog.require('some.package.Class');</code>
      </pre>

      <p>Запрещено:</p>
      <pre>
        <code class="language-js badcode prettyprint">// Дополнительные термины должны исходить из пространства имен.
const MyClassForBizzing = goog.require('some.package.MyClass');
// Псевдоним должен включать все конечные компоненты пространства имен.
const MyClass = goog.require('some.package.MyClassForBizzing');
// Псевдоним не должен маскировать собственный тип (здесь должно быть `const JspbMap`).
const Map = goog.require('jspb.Map');
// Не переносите goog.require строки более 80 символов.
const SomeDataStructure =
    goog.require('proto.identical.package.identifiers.SomeDataStructure');
// Псевдоним должен быть основан на пространстве имен.
const randomName = goog.require('something.else');
// Отсутствует пробел после двоеточия.
const {Foo:FooProto} = goog.require('some.package.proto.Foo');
// goog.requireType без псевдонима.
goog.requireType('some.package.with.a.Type');

/** 
 * @param {!some.unimported.Dependency} param Все внешние типы, использующиеся в JSDoc 
 *    аннотациях, должны быть потребованы с помощью goog.require, если не объявлено в externs. 
 */
 function someFunction(param) {
  // goog.require строки должны быть на верхнем уровне перед любым другим кодом.
  const alias = goog.require('my.long.name.alias');
  // ...
}</code>
      </pre>

      <h3 id="file-implementation">3.7 Реализация файла</h3>

      <p>
        Фактическая реализация следует после того, как вся информация о
        зависимостях объявлена (и разделена хотя бы одной пустой строкой).
      </p>

      <p>
        Она может состоять из любых модульных деклараций (константы, переменные,
        классы, функции и т.д.), а также любых экспортируемых символов.
      </p>

      <h2 id="formatting">4 Форматирование</h2>

      <p>
        <strong>Терминологическое примечание</strong>:
        <em>блокоподобная конструкция</em> относится к телу класса, функции,
        метода или блока кода, разделенного скобками. Обратите внимание, что по
        правилам <a href="#features-array-literals">??</a> и
        <a href="#features-object-literals">??</a> любой массив или объектный
        литерал может опционально обрабатываться, как если бы это была блочная
        конструкция.
      </p>

      <p>
        Подсказка: Используйте <code>clang-format</code>. Сообщество JavaScript
        приложило усилия, чтобы убедиться, что clang-format
        <q>правильно работает</q> в JavaScript файлах.
        <code>clang-format</code> имеет интеграцию с несколькими популярными
        редакторами.
      </p>

      <h3 id="formatting-braces">4.1 Скобки</h3>

      <h4 id="formatting-braces-all">
        4.1.1 Скобки используются для всех управляющих структур
      </h4>

      <p>
        Скобки требуются для всех управляющих структур (например,
        <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>,
        <code>while</code> и т.п.), даже если тело содержит один оператор.
        Первый оператор непустого блока должен начинаться с отдельной строки.
      </p>

      <p>Не разрешено:</p>

      <pre><code class="language-js badcode prettyprint">if (someVeryLongCondition()) doSomething();
for (let i = 0; i &lt; foo.length; i++) bar(foo[i]);</code></pre>

      <p>
        <strong>Исключение</strong>: Простой оператор if, который может
        поместиться целиком в одну строку без переноса (и в котором нет
        другого), может быть помещен в одной строке без фигурных скобок, когда
        он улучшает читабельность. Это единственный случай, когда управляющая
        структура может пропускать скобки и переводы строк.
      </p>

      <pre><code class="language-js prettyprint">if (shortCondition()) foo();</code></pre>

      <h4 id="formatting-nonempty-blocks">
        4.1.2 Непустые блоки: стиль K&amp;R
      </h4>

      <p>
        Скобки следуют стилю Кернигана и Ричи (<q
          ><a
            href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html"
            >египетские скобки</a
          ></q
        >) для <em>непустых</em> блоков и блочных конструкций, если:
      </p>

      <ul>
        <li>Никакого разрыва строки перед открывающей скобкой.</li>
        <li>Разрыв строки после открывающей скобки.</li>
        <li>Разрыв строки перед закрывающей скобкой.</li>
        <li>
          Разрыв строки после закрывающей скобки <em>if</em>. Данная фигурная
          скобка завершает оператор или тело оператора функции или класса или
          метод класса. В частности, после фигурной скобки <em>нет</em> разрыва
          строки, если за ней следует <code>else</code>, <code>catch</code>,
          <code>while</code> или запятая, точка с запятой или правая скобка.
        </li>
      </ul>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Внимание: это может не сработать.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}
</code></pre>

      <h4 id="formatting-empty-blocks">
        4.1.3 Пустые блоки: могут быть краткими
      </h4>

      <p>
        Пустой блок или блочно-подобная конструкция <em>может</em> быть закрыта
        сразу после открытия, но без символов, пробелов или разрыва строки между
        ними (например, <code>{}</code>), <strong>Если</strong> только это не
        является частью <em>многоблочного оператора</em> (который содержит
        непосредственно несколько блоков: <code>if</code>/<code>else</code> или
        <code>try</code>/<code>catch</code>/<code>finally</code>).
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">function doNothing() {}</code></pre>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">if (condition) {
  // &#8230;
} else if (otherCondition) {} else {
  // &#8230;
}

try {
  // &#8230;
} catch (e) {}
</code></pre>

      <h3 id="formatting-block-indentation">4.2 Блочный отступ: +2 пробела</h3>

      <p>
        Каждый раз, когда открывается новый блок или блочная конструкция, отступ
        увеличивается на два пробела. Когда блок заканчивается, отступ
        возвращается к предыдущему уровню отступа. Уровень отступа применяется
        как к коду, так и к комментариям по всему блоку. (см. пример в
        <a href="#formatting-nonempty-blocks">??</a>).
      </p>

      <h4 id="formatting-array-literals">
        4.2.1 Литералы массива: опционально <q>блочные</q>
      </h4>

      <p>
        Любой литерал массива может быть необязательно отформатирован так, как
        если бы он был «блочной конструкцией». Например, допустимые варианты
        ниже (<strong>не</strong> исчерпывающий список):
      </p>

      <pre><code class="language-js prettyprint columns">const a = [
  0,
  1,
  2,
];

const b =
    [0, 1, 2];

</code></pre>

      <pre><code class="language-js prettyprint columns">const c = [0, 1, 2];

someMethod(foo, [
  0, 1, 2,
], bar);
</code></pre>

      <p>
        Допускаются другие комбинации, особенно при подчеркивании семантических
        группировок между элементами, но они не должны использоваться только для
        уменьшения вертикального размера больших массивов.
      </p>

      <h4 id="formatting-object-literals">
        4.2.2 Объектные литералы: опционально <q>блочные</q>
      </h4>

      <p>
        Любой объектный литерал может быть отформатирован так, как если бы он
        был «блочной конструкцией». Применяются те же примеры, что и
        <a href="#formatting-array-literals">??</a>. Например, следующие примеры
        допустимы (<strong>не</strong> исчерпывающий список):
      </p>

      <pre><code class="language-js prettyprint columns">const a = {
  a: 0,
  b: 1,
};

const b =
    {a: 0, b: 1};
</code></pre>

      <pre><code class="language-js prettyprint columns">const c = {a: 0, b: 1};

someMethod(foo, {
  a: 0, b: 1,
}, bar);
</code></pre>

      <h4 id="formatting-class-literals">4.2.3 Литералы класса</h4>
      <p>
        Литералы класса (будь то объявления или выражения) имеют отступ в виде
        блоков. Не добавляйте точку с запятой после методов или после
        закрывающей скобки <em>объявления класса</em> (операторы, такие как
        присваивания, которые содержат <em>выражения</em> класса, по-прежнему
        заканчиваются точкой с запятой). Используйте ключевое слово
        <code>extends</code>, но не аннотацию <code>@extends</code> JSDoc, если
        только класс не расширяет шаблонизированный тип.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint columns">class Foo {
  constructor() {
    /** @type {number} */
    this.x = 42;
  }

  /** @return {number} */
  method() {
    return this.x;
  }
}
Foo.Empty = class {};
</code></pre>

      <pre><code class="language-js prettyprint columns">/** @extends {Foo&lt;string&gt;} */
foo.Bar = class extends Foo {
  /** @override */
  method() {
    return super.method() / 2;
  }
};

/** @interface */
class Frobnicator {
  /** @param {string} message */
  frobnicate(message) {}
}
</code></pre>

      <h4 id="formatting-function-expressions">
        4.2.4 Функциональные выражения
      </h4>

      <p>
        При объявлении анонимной функции в списке аргументов для вызова функции,
        тело функции имеет отступ на два пробела больше, чем предыдущая глубина
        отступа.
      </p>

      <p>Пример:</p>
      <pre><code class="language-js prettyprint">prefix.something.reallyLongFunctionName('whatever', (a1, a2) =&gt; {
  // Отступ тела функции +2 относительно глубины отступа
  // оператора на одну строку выше.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
    .thatsWrapped()
    .then((result) =&gt; {
      // Отступ тела функции +2 относительно глубины отступа
      // вызова '.then()'.
      if (result) {
        result.use();
      }
    });
</code></pre>

      <h4 id="formatting-switch-statements">4.2.5 Switch оператор</h4>

      <p>
        Как и в любом другом блоке, содержимое блока switch имеет отступ +2.
      </p>

      <p>
        После оператора <code>switch</code> добавляется новая строка и уровень
        отступа увеличивается на +2, точно так же, как если бы блок открывался.
        Явный блок может использоваться, если этого требует лексическая область
        видимости. После завершения оператора отступ возвращается на предыдущий
        уровень.
      </p>

      <p>
        Пустая строка необязательна между <code>break</code> и следующим
        случаем.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Неизвестное животное');
}
</code></pre>

      <h3 id="formatting-statements">4.3 Операторы</h3>

      <h4 id="formatting-one-statement-perline">
        4.3.1 Один оператор на строку
      </h4>

      <p>После каждого оператора делается перевод строки.</p>

      <h4 id="formatting-semicolons-are-required">
        4.3.2 Необходима точка с запятой.
      </h4>

      <p>
        Каждый оператор должен заканчиваться точкой с запятой. Использование
        автоматической точки с запятой запрещено.
      </p>

      <h3 id="formatting-column-limit">4.4 Лимит строки: 80 символов</h3>

      <p>
        Код JavaScript имеет ограничение столбца в 80 символов. За исключением
        случаев, указанных ниже, любая строка, которая превысила бы этот предел,
        должна быть перенесена, как описано в
        <a href="#formatting-line-wrapping">??</a>.
      </p>

      <p><strong>Исключения:</strong></p>

      <ol>
        <li>
          Операторы <code>goog.module</code>, <code>goog.require</code> и
          <code>goog.requireType</code> (см.
          <a href="#file-goog-module">??</a> и
          <a href="#file-goog-require">??</a>).
        </li>
        <li>
          ES модули <code>import</code> и операторы
          <code>export from</code> (см. <a href="#es-module-imports">??</a> и
          <a href="#es-module-export-from">??</a>).
        </li>
        <li>
          Линии, в которых соблюдение предела столбцов невозможно или может
          препятствовать обнаружению. Примеры включают в себя:
          <ul>
            <li>Длинный URL, который должен быть кликабельным в источнике.</li>
            <li>Команда консоли, предназначенная для копирования и вставки</li>
            <li>
              Длинный строковый литерал, который может потребоваться полностью
              скопировать или найти (например, длинный путь к файлу).
            </li>
          </ul>
        </li>
      </ol>

      <h3 id="formatting-line-wrapping">4.5 Перенос строк</h3>

      <p>
        <strong>Терминологическое примечание</strong>:
        <em>Перенос строки</em> разбивает кусок кода на несколько строк в
        соответствии с ограничением по количеству символов, где фрагмент в
        противном случае мог бы поместиться в одну строку в соответствии с
        правилами данного руководства.
      </p>

      <p>
        Не существует всеобъемлющего правила, показывающего, как
        <em>именно</em> переносить строки в каждой ситуации. Очень часто есть
        несколько допустимых способов переноса строк в одном и том же фрагменте
        кода.
      </p>

      <p>
        Примечание: Хотя типичная причина переноса строки заключается в том,
        чтобы избежать переполнения предела столбца — даже код, который на самом
        деле помещается в пределе допустимого количества символов, может быть
        разбит строкой на усмотрение автора.
      </p>

      <p>
        Совет: извлечение метода или локальной переменной может решить проблему
        без необходимости переноса строки.
      </p>

      <h4 id="formatting-where-to-break">4.5.1 Когда переносить</h4>

      <p>
        Основная директива переноса строк такова: предпочитайте переносить на
        <strong>более высоком синтаксическом уровне</strong>.
      </p>

      <p>Предпочтительно:</p>
      <pre><code class="language-js prettyprint">currentEstimate =
    calc(currentEstimate + x * currentEstimate) /
        2.0;
</code></pre>

      <p>Нежелательно:</p>

      <pre><code class="language-js prettyprint badcode">currentEstimate = calc(currentEstimate + x *
    currentEstimate) / 2.0;
</code></pre>

      <p>
        В предыдущем примере синтаксические уровни от самого высокого до самого
        низкого следующие: определение, деление, вызов функции, параметры,
        числовая константа.
      </p>

      <p>Операторы переносятся следующим образом:</p>

      <ol>
        <li>
          Когда у оператора разрывается строка, разрыв следует за оператором.
          (Обратите внимание, что это не та же практика, что и в стиле Google
          для Java.)
          <ol>
            <li>
              Это не относится к <q>точке</q> (<code>.</code>), которая на самом
              деле не является оператором.
            </li>
          </ol>
        </li>
        <li>
          Имя метода или конструктора остается присоединенным к открытой круглой
          скобке (<code>(</code>), которая следует за ней.
        </li>
        <li>
          Запятая (<code>,</code>) остается прикрепленной к символу, который
          предшествует ей.
        </li>
      </ol>

      <blockquote>
        <p>
          Примечание: Основной целью переноса строк является наличие понятного
          кода, а не обязательно кода, который помещается в наименьшее
          количество строк.
        </p>
      </blockquote>

      <h4 id="formatting-indent">
        4.5.2 Отступ строк с протяженностью не менее +4 пробелов
      </h4>

      <p>
        При переносе строк каждая строка после первой (каждая
        <em> строка продолжения </em>) имеет отступ не менее +4 от исходной
        строки, если только она не подпадает под правила отступа блока.
      </p>

      <p>
        Когда имеется несколько строк продолжения, отступ может выходить за
        пределы +4 в зависимости от ситуации. Как правило, строки продолжения на
        более глубоком синтаксическом уровне имеют отступ с большим числом,
        кратным 4. Две строки используют один и тот же уровень отступа, если и
        только если они начинаются с синтаксически равных элементов.
      </p>

      <p>
        <a href="#formatting-horizontal-alignment">??</a> объясняет
        нежелательную практику использования переменного числа пробелов для
        выравнивания определенных конструкций с предыдущим типом строк.
      </p>

      <h3 id="formatting-whitespace">4.6 Пробелы</h3>
      <h4 id="formatting-vertical-whitespace">4.6.1 Вертикальный пробел</h4>

      <p>Одна пустая строка ставится:</p>

      <ol>
        <li>
          Между последовательными методами в литерале класса или объекта
          <ol>
            <li>
              Исключение: пустая строка между двумя последовательными
              определениями свойств в литерале объекта (без другого кода между
              ними) является необязательной. Такие пустые строки используются по
              мере необходимости для создания
              <em>логических группировок</em> полей.
            </li>
          </ol>
        </li>
        <li>
          Внутри тел методов имеет смысл создавать
          <em>логические группировки</em> операторов. Пустые строки в начале или
          конце тела функции не допускаются.
        </li>
        <li>
          <em>Необязательно</em> перед первым или после последнего метода в
          литерале класса или объекта (не рекомендуется и не поощряется).
        </li>
        <li>
          Как того требуют другие разделы этого документа (например,
          <a href="#file-goog-require">??</a>).
        </li>
      </ol>

      <p>
        <em> Несколько </em> последовательных пустых строк разрешены, но никогда
        не требуются (и не поощряются).
      </p>

      <h4 id="formatting-horizontal-whitespace">
        4.6.2 Горизонтальный пробел
      </h4>

      <p>
        Использование горизонтального пробела зависит от местоположения и
        подразделяется на три широкие категории: <em> ведущий </em> (в начале
        строки), <em> конечный </em> (в конце строки) и <em> внутренний</em>.
        Ведущий пробел (то есть отступ) рассматривается в другом месте. Конечный
        пробел запрещен.
      </p>

      <p>
        Кроме случаев, когда этого требуют правила языка или другие правила
        стиля, а также литералы, комментарии и JSDoc, один ASCII пробел
        появляется <strong>только</strong> в следующих местах:
      </p>

      <ol>
        <li>
          Отделение любого зарезервированного слова (например, <code>if</code>,
          <code>for</code> или <code>catch</code>), за исключением
          <code>function</code> и <code>super</code> начиная с открытой скобки
          (<code>(</code>), которая следует за зарезервированным словом в этой
          же строке.
        </li>

        <li>
          Отделение любого зарезервированного слова (такого как
          <code>else</code> или <code>catch</code>) от закрывающей фигурной
          скобки (<code>}</code>), которая предшествует ему в этой строке.
        </li>

        <li>
          Перед любой открытой фигурной скобкой (<code>{</code>), с двумя
          исключениями:

          <ol>
            <li>
              Перед литералом объекта, который является первым аргументом
              функции или первым элементом в литерале массива (например,
              <code> foo ({a: [{c: d}]}) </code>).
            </li>
            <li>
              В расширении шаблона, так как это запрещено языком (например,
              валидно:
              <code>`ab${1 + 2}cd`</code>, не валидно:
              <code class="badcode">`xy$ {3}z`</code>).
            </li>
          </ol>
        </li>

        <li>С обеих сторон любой бинарного или тернарного оператор.</li>

        <li>
          После запятой (<code>,</code>) или точки с запятой (<code>;</code>).
          Обратите внимание, что пробелы <em>никогда</em> не разрешены перед
          этими символами.
        </li>

        <li>После двоеточия (<code>:</code>) в литерале объекта.</li>

        <li>
          По обе стороны от двойной косой черты (<code>//</code>), начинающей
          комментарий в конце строки. Здесь разрешено использование нескольких
          пробелов, но это не обязательно.
        </li>

        <li>
          После символа блочного комментария и с обеих сторон закрывающих
          символов (например, для кратких объявлений типов, приведений и
          комментариев имени параметра:
          <code>this.foo = /** @type {number} */ (bar)</code>; или
          <code>function(/** string */ foo) {</code>; или
          <code>baz(/* buzz= */ true)</code>).
        </li>
      </ol>

      <h4 id="formatting-horizontal-alignment">
        4.6.3 Горизонтальное выравнивание: не рекомендуется
      </h4>

      <p>
        <strong>Терминологическое примечание:</strong> Горизонтальное
        выравнивание — это практика добавления в ваш код переменного числа
        дополнительных пробелов с целью отображения определенных символов
        непосредственно под некоторыми другими символами в предыдущих строках.
      </p>

      <p>
        Эта практика разрешена, но, как правило,
        <strong>не рекомендуется</strong> в Google Style. Даже не требуется
        <em>поддерживать</em> горизонтальное выравнивание в местах, где оно уже
        использовалось.
      </p>

      <p>
        Вот пример без выравнивания, за которым следует пример с выравниванием.
        Оба разрешены, но последний не рекомендуется:
      </p>

      <pre><code class="language-js prettyprint">{
  tiny: 42, // хорошо 
  longer: 435, // тоже хорошо
};

{
  tiny:   42,  // разрешено, но требует будущего редактирования 
  longer: 435, // может остаться без выравнивания
};
</code></pre>

      <p>
        Совет: Выравнивание может улучшить читаемость, но создает проблемы для
        дальнейшего обслуживания. Допустим, есть изменение, которое должно
        касаться только одной строки. Это изменение может оставить искаженное
        ранее приятное форматирование. Чаще всего это побуждает разработчика
        (возможно, вас) также корректировать пробелы на близлежащих линиях. Это
        изменение в одну строку потребовало изменения нескольких строк. В лучшем
        случае это может привести к бессмысленной занятой работе, но в худшем
        это еще и исказит информацию об истории версий, замедлит работу
        рецензентов и усугубит конфликты слияний.
      </p>

      <h4 id="formatting-function-arguments">4.6.4 Аргументы функций</h4>

      <p>
        Предпочитайте помещать все аргументы функции в одну строку с именем
        функции. Если это превысит ограничение в 80 столбцов, аргументы должны
        быть перенесены для удобочитаемости. Чтобы сэкономить место, вы можете
        сделать перенос строки как можно ближе к 80 символам или поместить
        каждый аргумент в отдельной строке, чтобы улучшить читаемость. Отступы
        должны быть в размере 4-х пробелов. Выравнивание в скобках разрешено, но
        не рекомендуется. Ниже приведены наиболее распространенные шаблоны для
        переноса аргументов:
      </p>

      <pre><code class="language-js prettyprint">// Аргументы начинаются с новой строки, с отступом в четыре пробела. Предпочтительнее,
// когда аргументы помещаются не в одну строку с именем функции (или ключевым словом
// "function"), а помещаются полностью на второй строке. Такой подход работает с длинными
// именами функций, позволяет делать переименование без изменения отступов.
doSomething(    
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {  
  // &#8230;
}

// Если список аргументов длинный (больше 80 символов), сделайте перенос. 
// Такой подход использует меньше вертикального пространства, но нарушает
// правило прямоугольника и поэтому не рекомендуется.
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // &#8230;
}

// Четыре пробела, один аргумент в строке. Работает с длинными именами
// функций, позволяет переименование, и выделяет каждый аргумент.
doSomething(  
    veryDescriptiveArgumentNumberOne, 
    veryDescriptiveArgumentTwo,    
    tableModelEventHandlerProxy,    
    artichokeDescriptorAdapterIterator) {
  // &#8230;
}</code></pre>

      <h3 id="formatting-grouping-parentheses">
        4.7 Группировка скобок: рекомендуется
      </h3>

      <p>
        Необязательные групповые скобки опускаются только в том случае, если
        автор и рецензент согласны с тем, что без них нет никакой разумной
        вероятности, что код будет неверно истолкован, и что они не сделали бы
        код более удобным для чтения. Неразумно предполагать, что каждый
        читатель запомнил всю таблицу операторов.
      </p>

      <p>
        Не используйте лишние скобки вокруг всего выражения после
        <code>delete</code>, <code>typeof</code>, <code>void</code>,
        <code>return</code>, <code>throw</code>, <code>case</code>,
        <code>in</code>, <code>of</code> или <code>yield</code>.
      </p>

      <p>
        Круглые скобки необходимы для приведения типов:
        <code>/** @тип {!Foo}. */(foo)</code>.
      </p>

      <h3 id="formatting-comments">4.8 Комментарии</h3>

      <p>
        В этом разделе рассматриваются <em>комментарии реализации</em>. JSDoc
        рассматривается отдельно в <a href="#jsdoc">??</a>.
      </p>

      <h4 id="formatting-block-comment-style">
        4.8.1 Стиль блочных комментариев
      </h4>

      <p>
        Блочные комментарии снабжены отступом на том же уровне, что и окружающий
        код. Они могут быть в стиле <code>/* &#8230; */</code> или
        <code>//</code>. Для многострочных комментариев
        <code>/* &#8230; */</code> последующие строки должны начинаться с
        <code>*</code>, выровненного с <code>*</code> на предыдущей строке,
        чтобы комментарии были очевидны без лишнего контекста.
      </p>

      <pre><code class="language-js prettyprint">/*
 * Это выглядит
 * хорошо.
 */

// Тоже
// хорошо.

/* Аналогично */
</code></pre>

      <p>
        Комментарии не вставляются в поля, отрисованные звездочками или другими
        символами.
      </p>

      <p>
        Не используйте JSDoc (<code>/** &#8230; */</code>) для комментариев,
        описывающих реализацию.
      </p>

      <h4 id="formatting-param-name-comments">
        4.8.2 Комментарии для имен параметров
      </h4>

      <p>
        Комментарии для имен параметров следует использовать во всех случаях,
        когда значение и имя метода не передают в достаточной степени смысл, а
        рефакторинг метода для большей ясности невозможен. Предпочтительный для
        них формат — перед значением с <q>=</q>:
      </p>

      <pre><code class="language-js prettyprint">someFunction(obviousParam, /* shouldRender= */ true, /* name= */ 'hello');</code></pre>

      <p>
        Для согласованности с окружающим кодом можно поместить их после значения
        без <q>=</q>:
      </p>

      <pre><code class="language-js prettyprint">someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);</code></pre>

      <h2 id="language-features">5 Языковые особенности</h2>

      <p>
        JavaScript включает в себя множество сомнительных (и даже опасных)
        возможностей. В этом разделе описывается, какие функции могут
        использоваться, а какие нет, и какие дополнительные ограничения
        накладываются на их использование.
      </p>

      <h3 id="features-local-variable-declarations">
        5.1 Объявление локальных переменных
      </h3>

      <h4 id="features-use-const-and-let">
        5.1.1 Используйте <code>const</code> и <code>let</code>
      </h4>

      <p>
        Объявляйте все локальные переменные либо с помощью <code>const</code>,
        либо с помощью <code>let</code>. Используйте const по умолчанию, если
        только переменная не нуждается в переназначении. Ключевое слово
        <code class="badcode">var</code> не должно использоваться.
      </p>

      <h4 id="features-one-variable-per-declaration">
        5.1.2 Одна переменная для одного определения
      </h4>

      <p>
        Каждая декларация локальной переменной объявляет только одну переменную:
        декларации типа <code class="badcode">let a = 1, b = 2;</code> не
        используются.
      </p>

      <h4 id="features-declared-when-needed">
        5.1.3 Определяйте, когда требуется, но инициализируйте — как можно
        быстрее
      </h4>

      <p>
        Локальные переменные обычно <strong>не</strong> объявляются в начале
        блочной или блокоподобной конструкции, которая их содержит. Вместо этого
        локальные переменные объявляются близко к точке, в которой они будут
        впервые использованы (в пределах разумного), чтобы минимизировать их
        охват.
      </p>

      <h4 id="features-declare-types-as-needed">
        5.1.4 Объявлять типы по мере необходимости
      </h4>

      <p>
        Аннотации типа JSDoc могут быть добавлены либо в строке над объявлением,
        либо в строке перед именем переменной, если нет других JSDoc.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">const /** !Array&lt;number&gt; */ data = [];

/**
 * Какое-то описание.
 * @type {!Array&lt;number&gt;}
 */
const data = [];
</code></pre>

      <p>
        Смешивание строчных (inline) и JSDoc стилей не допускается: компилятор
        будет обрабатывать только первые JSDoc комментарии, и строчные будут
        потеряны.
      </p>

      <pre><code class="language-js prettyprint badcode">/** Какое-то описание. */
const /** !Array&lt;number&gt; */ data = [];
</code></pre>

      <p>
        Подсказка: Существует множество случаев, когда компилятор может сделать
        вывод о шаблонизированном типе, но не о его параметрах. В частности, это
        происходит, когда вызывающий литерал или конструктор не включает в себя
        никаких значений с типом параметра (например, пустые массивы, объекты,
        <code>Map</code> или <code>Set</code>), или если переменная изменяется в
        рамках замыкания. Особенно полезны в этих случаях аннотации к типам
        локальных переменных, так как в противном случае компилятор выдаст
        параметр шаблона как неизвестный (<code>unknown</code>).
      </p>

      <h3 id="features-array-literals">5.2 Литералы массива</h3>

      <h4 id="features-arrays-trailing-comma">
        5.2.1 Используйте закрывающие запятые
      </h4>

      <p>
        Ставьте закрывающую запятую всякий раз, когда происходит разрыв строки
        между последним элементом и закрывающей скобкой.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">const values = [
  'first value',
  'second value',
];
</code></pre>

      <h4 id="features-arrays-ctor">
        5.2.2 Не используйте вариационный конструктор <code>массива</code>
      </h4>

      <p>
        Конструктор подвержен ошибкам при добавлении или удалении аргументов.
        Вместо этого используйте литерал.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">const a1 = new Array(x1, x2, x3);
const a2 = new Array(x1, x2);
const a3 = new Array(x1);
const a4 = new Array();
</code></pre>

      <p>
        Это работает, как и ожидалось, за исключением третьего случая: если
        <code>x1</code> целое число, то <code>a3</code> — массив размером
        <code>x1</code>, где все элементы <code>неопределены</code>. Если
        <code>x1</code> — любое другое число, то будет брошено исключение, а
        если это что-то другое, то это будет одноэлементный массив.
      </p>

      <p>Вместо этого используйте</p>

      <pre><code class="language-js prettyprint">const a1 = [x1, x2, x3];
const a2 = [x1, x2];
const a3 = [x1];
const a4 = [];
</code></pre>

      <p>
        Явное определение массива заданной длины с помощью
        <code>new Array(length)</code> разрешено, когда это необходимо.
      </p>

      <h4 id="features-arrays-non-numeric-properties">
        5.2.3 Нецифровые свойства
      </h4>

      <p>
        Не определяйте и не используйте нецифровые свойства вместе с массивом
        (кроме
        <code>length</code>). Вместо этого используйте <code>Map</code> (или
        <code>Object</code>).
      </p>

      <h4 id="features-arrays-destructuring">5.2.4 Деструктуризация</h4>

      <p>
        Для выполнения деструктуризации (например, при распаковке нескольких
        значений из одного массива или <code>iterable</code>), можно
        использовать литералы массива слева от определения . Заключительный
        <q>rest</q> элемент может быть включен в конец (без пробела между
        <code>...</code> и именем переменной). Значения должны быть опущены,
        если они не используются.
      </p>

      <pre><code class="language-js prettyprint">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;</code></pre>

      <p>
        Деструктуризация также может быть использована для параметров функции
        (обратите внимание, что имя параметра требуется, но игнорируется).
        Всегда указывайте <code>[]</code> в качестве значения по умолчанию, если
        параметр деструктурированного массива является необязательным, а также
        указывайте значения по умолчанию с левой стороны:
      </p>

      <pre><code class="language-js prettyprint">/** @param {!Array&lt;number&gt;=} param1 */
function optionalDestructuring([a = 4, b = 2] = []) { &#8230; };</code></pre>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">function badDestructuring([a, b] = [4, 2]) { &#8230; };</code></pre>

      <p>
        Совет: Для распаковки\упаковки нескольких значений в параметры функции
        или <code>return</code>, предпочитайте, когда это возможно,
        деструктуризацию объекта, а не массива, так как это позволяет именовать
        отдельные элементы и указывать для каждого из них свой тип.
      </p>

      <h4 id="features-arrays-spread-operator">5.2.5 Оператор расширения</h4>

      <p>
        Литералы массива могут включать оператор расширения (<code>...</code>)
        для извлечения элементов из одного или нескольких
        <code>iterables</code>. Оператор расширения следует использовать вместо
        более неудобных конструкций с <code>Array.prototype</code>. Пробел после
        <code>...</code> отсутствует.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">[...foo]   // предпочтительнее, чем Array.prototype.slice.call(foo)
[...foo, ...bar]   // предпочтительнее, чем foo.concat(bar)</code></pre>

      <h3 id="features-object-literals">5.3 Литералы объекта</h3>

      <h4 id="features-objects-use-trailing-comma">
        5.3.1 Использование закрывающих запятых
      </h4>

      <p>
        Вставляйте закрывающую запятую всякий раз, когда есть разрыв строки
        между конечным свойством и закрывающей скобкой.
      </p>

      <h4 id="features-objects-ctor">
        5.3.2 Не используйте конструктор <code>Object</code>
      </h4>

      <p>
        Хотя <code>Object</code> не имеет тех же проблем, что и
        <code>Array</code>, для согласованности он все равно запрещен. Вместо
        этого используйте (<code>{}</code> или <code>{a: 0, b: 1, c: 2}</code>).
      </p>

      <h4 id="features-objects-mixing-keys">
        5.3.3 Не смешивайте ключи с кавычками и без
      </h4>

      <p>
        Объектные литералы могут представлять собой либо <em>structs</em> (с
        ключами и/или символами без кавычек), либо <em>dicts</em> (с и/или
        вычисляемыми ключами в кавычках). Не смешивайте эти типы ключей в одном
        объектном литерале.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">{
  width: 42, // ключ без кавычек в стиле struct
  'maxWidth': 43, // ключ с кавычками в стиле dict
}
</code></pre>

      <p>
        Это также распространяется на передачу имени свойства функциям, таким
        как <code>hasOwnProperty</code>. Это может нарушить компиляцию кода, так
        как компилятор не может переименовать/обфусцировать строковый литерал.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">/** @type {{width: number, maxWidth: (number|undefined)}} */
const o = {width: 42};
if (o.hasOwnProperty('maxWidth')) {
  ...
}
</code></pre>

      <p>Лучше всего это реализовать как:</p>

      <pre><code class="language-js prettyprint">/** @type {{width: number, maxWidth: (number|undefined)}} */
const o = {width: 42};
if (o.maxWidth != null) {
  ...
}
</code></pre>

      <h4 id="features-objects-computed-property-names">
        5.3.4 Вычисляемые имена свойств
      </h4>

      <p>
        Вычисляемые имена свойств (например, <code>{['key' + foo()]: 42}</code>)
        разрешены, заключаются в кавычки и считаются ключами в dict-стиле, (т.е.
        не должны смешиваться с ключами в кавычках), если только вычисленное
        свойство не является
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"
          >символом</a
        >
        (например, <code>[Symbol.iterator]</code>). Значения перечислений также
        могут быть использованы для вычисляемых ключей, но не должны смешиваться
        с незнаковыми ключами в одном и том же литерале.
      </p>

      <h4 id="features-objects-method-shorthand">
        5.3.5 Сокращенное объявление метода
      </h4>

      <p>
        Методы могут быть определены в объектных литералах с помощью
        сокращенного варианта (<code>{method() {&#8230; }}</code>) вместо
        двоеточия, сразу за которым следует <code>function</code> или литерал
        стрелочной функции.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">return {
  stuff: 'candy',
  method() {
    return this.stuff;  // Вернет 'candy'
  },
};
</code></pre>

      <p>
        Обратите внимание, что <code>this</code> в сокращенном объявлении метода
        или функции ссылается на сам литерал объекта, в то время как
        <code>this</code> в функции со стрелочном объявлением ссылается на
        область видимости, выходящую за рамки литерала объекта.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">class {
  getObjectLiteral() {
    this.stuff = 'fruit';
    return {
      stuff: 'candy',
      method: () =&gt; this.stuff,  // Вернет 'fruit'
    };
  }
}
</code></pre>

      <h4 id="features-objects-shorthand-properties">
        5.3.6 Сокращенные свойства
      </h4>

      <p>В литералах объекта допустимы сокращенные свойства.</p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">const foo = 1;
const bar = 2;
const obj = {
  foo,
  bar,
  method() { return this.foo + this.bar; },
};
assertEquals(3, obj.method());
</code></pre>

      <h4 id="features-objects-destructuring">5.3.7 Деструктуризация</h4>

      <p>
        Деструктуризация объектов может быть использована слева от определения
        для распаковки нескольких значений из одного объекта.
      </p>

      <p>
        Деструктурируемые объекты также могут использоваться в качестве
        параметров функции, но должны быть максимально простыми: может быть
        только один уровень свойств без кавычек. Более глубокие уровни
        вложенности и вычисляемые свойства не могут использоваться при
        деструктуризации параметров. Указывайте значения по умолчанию в левой
        части деструктурируемого параметра (<code
          >{str = 'some default'} = {}</code
        >, а не <code class="badcode">{str} = {str: some default'}</code>), и
        если параметр сам по себе необязателен, то по умолчанию он должен иметь
        значение <code>{}</code>. JSDoc'y деструктурируемого параметра может быть
        присвоено любое имя (имя не используется, но требуется компилятору).
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">/**
 * @param {string} ordinary
 * @param {{num: (number|undefined), str: (string|undefined)}=} param1
 *     num: Количество раз, сколько выполнить действие
 *     str: Описание того, что делать
 */
function destructured(ordinary, {num, str = 'some default'} = {})
</code></pre>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */
function nestedTooDeeply({x: {num, str}}) {};
/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */
function nonShorthandProperty({num: a, str: b} = {}) {};
/** @param {{a: number, b: number}} param1 */
function computedKey({a, b, [a + b]: c}) {};
/** @param {{a: number, b: string}=} param1 */
function nontrivialDefault({a, b} = {a: 2, b: 4}) {};
</code></pre>

      <p>
        Деструктуризация также может быть использована для
        <code>goog.require</code> операторов, и в этом случае не должна быть
        перенесена на другую строку: оператор занимает одну строку, независимо
        от ее длины (см. <a href="#file-goog-require">??</a>).
      </p>

      <h4 id="features-objects-enums">5.3.8 Перечисления</h4>

      <p>
        Перечисления определяются добавлением аннотации <code>@enum</code> к
        обычному объекту. Дополнительные свойства не могут быть добавлены в
        перечисление после его определения. Перечисления должны быть
        константными, и все значения перечислений должны быть полностью
        неизменяемыми.
      </p>

      <pre><code class="language-js prettyprint">/**
 * Поддерживаемые температурные шкалы.
 * @enum {string}
 */
const TemperatureScale = {
  CELSIUS: 'celsius',
  FAHRENHEIT: 'fahrenheit',
};

/**
 * Перечисление с двумя вариантами.
 * @enum {number}
 */
const Option = {
  /** Используемая опция должна быть первой. */
  FIRST_OPTION: 1,
  /** Второй среди двух вариантов. */
  SECOND_OPTION: 2,
};
</code></pre>

      <h3 id="features-classes">5.4 Классы</h3>

      <h4 id="features-classes-constructors">5.4.1 Конструкторы</h4>
      <p>
        Конструкторы являются необязательными. Конструкторы подклассов должны
        вызывать <code>super()</code> перед установкой любых полей или иным
        обращением к <code>this</code>. Интерфейсы должны объявлять неметодные
        свойства в конструкторе.
      </p>

      <h4 id="features-classes-fields">5.4.2 Поля (fields)</h4>

      <p>
        Устанавливайте все поля объекта (т.е. все свойства, кроме методов) в
        конструкторе. Аннотируйте поля, которые никогда не переназначаются, с
        помощью <code>@const</code>. Аннотируйте непубличные поля подходящими
        аннотациями видимости (<code>@private</code>, <code>@protected</code>,
        <code>@package</code>) и заканчивайте все <code>@private</code> имена
        полей подчеркиванием. Поля никогда не устанавливаются в конкретный
        <code>prototype</code> класса.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">class Foo {
  constructor() {
    /** @private @const {!Bar} */
    this.bar_ = computeBar();

    /** @protected @const {!Baz} */
    this.baz = computeBaz();
  }
}</code></pre>

      <p>
        Подсказка: Свойства никогда не следует добавлять или удалять из
        экземпляра класса после завершения работы конструктора, так как это
        существенно затрудняет работу виртуальной машины (которая пытается
        провести оптимизацию). При необходимости, поля, которые инициализируются
        позже, должны быть явно установлены как
        <code>undefined</code> в конструкторе для предотвращения последующих
        изменений класса. Добавление <code>@struct</code> в объект будет
        проверять, что необъявленные свойства не добавляются/запрашиваются.
        Классы добавляют это по умолчанию.
      </p>

      <h4 id="features-classes-computed-properties">
        5.4.3 Вычисляемые свойства
      </h4>

      <p>
        Вычисляемые свойства могут использоваться в классах только в том случае,
        если свойство является символом. Свойства в dict-стиле (то есть,
        вычисляемые не символьные или заключенные в кавычки ключи, как определено
        в
        <a href="#features-objects-mixing-keys">??</a>), не допускаются. Метод
        <code>[Symbol.iterator]</code> должен быть определен для любых классов,
        логически итерабельных. Кроме того, <code>Symbol</code> следует
        использовать экономно.
      </p>

      <p>
        Совет: будьте осторожны с использованием любых других встроенных
        символов (например, <code>Symbol.isConcatSpreadable</code>), так как они
        не заменяются (полифилируются) компилятором и поэтому не будут работать
        в старых браузерах.
      </p>

      <h4 id="features-classes-static-methods">5.4.4 Статические методы</h4>

      <p>
        Там, где это не мешает читабельности, предпочитайте модульно локальные
        функции, а не приватные статические методы.
      </p>

      <p>
        Статические методы должны вызываться только для самого базового класса.
        Статические методы не должны вызываться для переменных, содержащих
        динамический экземпляр, который может быть как конструктором, так и
        конструктором подкласса (и должен определяться с помощью
        <code>@nocollapse</code>, если он существует), и не должны вызываться
        непосредственно для подкласса, который не определяет данный метод.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">class Base { /** @nocollapse */ static foo() {} }
class Sub extends Base {}
function callFoo(cls) { cls.foo(); }  // запрещено: не вызывайте статические методы динамически
Sub.foo();  // запрещено: не вызывайте статические методы в подклассах, которые сами их не определили
</code></pre>

      <h4 id="features-classes-old-style">
        5.4.5 Объявление классов в старом стиле
      </h4>

      <p>
        Хотя классы ES6 являются предпочтительными, есть случаи, когда классы
        ES6 не могут быть использованы. Например:
      </p>

      <ol>
        <li>
          <p>
            Если существуют или будут существовать подклассы, включая
            фреймворки, которые создают подклассы, которые не могут быть
            немедленно изменены для использования синтаксиса классов ES6. Если
            бы такой класс использовал синтаксис ES6, то все последующие
            подклассы, не использующие синтаксис класса ES6 — должны были бы
            быть изменены.
          </p>
        </li>

        <li>
          <p>
            Фреймворки, которым необходимо значение
            <code>this</code> перед вызовом конструктора суперкласса, поскольку
            конструкторы с ES6 суперклассами не имеют доступа к экземпляру
            <code>this</code> до тех пор, пока не завершится вызов
            <code>super</code>.
          </p>
        </li>
      </ol>

      <p>
        Во всех других случаях: <code>let</code>, <code>const</code>, параметры
        по умолчанию, стрелочные функции и др. должны использоваться там, где
        это возможно.
      </p>

      <p>
        <code>goog.defineClass</code> допускает определение, похожее на
        определение класса, аналогичное синтаксису класса ES6:
      </p>

      <pre><code class="language-javascript">let C = goog.defineClass(S, {
  /**
   * @param {string} value
   */
  constructor(value) {
    S.call(this, 2);
    /** @const */
    this.prop = value;
  },

  /**
   * @param {string} param
   * @return {number}
   */
  method(param) {
    return 0;
  },
});
</code></pre>

      <p>
        В качестве альтернативы, в то время как
        <code>goog.defineClass</code> должен быть предпочтительным для всего
        нового кода, более традиционный синтаксис также разрешен.
      </p>

      <pre><code class="language-javascript">/**
  * @constructor @extends {S}
  * @param {string} value
  */
function C(value) {
  S.call(this, 2);
  /** @const */
  this.prop = value;
}
goog.inherits(C, S);

/**
 * @param {string} param
 * @return {number}
 */
C.prototype.method = function(param) {
  return 0;
};
</code></pre>

      <p>
        Свойства экземпляра должны быть определены в конструкторе после вызова
        конструктора суперкласса, если есть суперкласс. Методы должны быть
        определены через прототип конструктора.
      </p>

      <p>
        Правильно определить иерархии конструкторов прототипа сложнее, чем
        кажется на первый взгляд! По этой причине лучше всего использовать
        <code>goog.inherits</code> из
        <a href="http://code.google.com/closure/library/">Google Closure</a>.
      </p>

      <h4 id="features-classes-prototypes">
        5.4.6 Не взаимодействуйте напрямую с <code>prototype</code>
      </h4>

      <p>
        Ключевое слово <code>class</code> позволяет более четко и читаемо
        определить класс, чем определение свойств <code>прототипа</code>.
        Обычный код класса не должен иметь никаких взаимодействий с точки зрения
        бизнес-логики с этими объектами, хотя они все еще полезны для
        определения классов, как говорится в
        <a href="#features-classes-old-style">??</a>. Смешивать и модифицировать
        прототипы встроенных объектов явно — запрещено.
      </p>

      <p>
        <strong>Исключения</strong>: Коду фреймворка (например, Polymer или
        Angular) может потребоваться использовать <code>prototype</code>, и не
        следует прибегать к обходным путям, чтобы избежать этого.
      </p>

      <h4 id="features-classes-getters-and-setters">
        5.4.7 Getters и Setters
      </h4>

      <p>
        Не используйте
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get"
          >JavaScript getter и setter свойства</a
        >. Они потенциально неочевидны и трудны в понимании, а также имеют
        ограниченную поддержку в компиляторе. Вместо этого предоставьте обычные
        методы.
      </p>

      <p>
        <strong>Исключения</strong>: бывают ситуации, когда определение геттера
        или сеттера неизбежно (например, фреймворки с привязкой данных, такие
        как Angular и Polymer, или для совместимости с внешними API, который
        невозможно настроить). Только в этих случаях можно использовать геттеры
        и сеттеры <em>с осторожностью</em> и при условии, что они определены с
        помощью короткого вида записи метода <code>get</code> и
        <code>set</code> или <code>Object.defineProperties</code> (не
        <code>Object.defineProperty</code>, что мешает переименованию свойств).
        Геттеры <strong>не должны</strong> изменять видимое состояние.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">class Foo {
  get next() { return this.nextId++; }
}
</code></pre>

      <h4 id="features-classes-overriding-tostring">
        5.4.8 Переопределение toString
      </h4>

      <p>
        Метод <code>toString</code> может быть переопределен, но должен всегда
        правильно выполняться и никогда не иметь видимых побочных эффектов.
      </p>

      <p>
        Совет: Остерегайтесь, в частности, вызова других методов из toString,
        так как иногда это может привести к бесконечным циклам.
      </p>

      <h4 id="features-classes-interfaces">5.4.9 Интерфейсы</h4>

      <p>
        Интерфейсы могут быть объявлены с помощью <code>@interface</code> или
        <code>@record</code>. Интерфейсы, объявленные с помощью
        <code>@record</code>, могут быть явно (т.е. через
        <code>@implements</code>) или неявно реализованы классом или литералом
        объекта.
      </p>

      <p>
        Все тела нестатических методов в интерфейсе должны быть пустыми блоками.
        Поля должны быть объявлены как неинициализированные свойства в
        конструкторе класса.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">/**
 * Что-то, с чем можно взаимодействовать
 * @record
 */
class Frobnicator {
  constructor() {
    /** @type {number} Количество попыток до завершения */
    this.attempts;
  }

  /**
   * Выполняет взаимодействие в соответствии с заданной стратегией
   * @param {!FrobnicationStrategy} strategy
   */
  frobnicate(strategy) {}
}

</code></pre>

      <h4 id="features-classes-abstract-classes">5.4.10 Абстрактные классы</h4>
      <p>
        При необходимости используйте абстрактные классы. Абстрактные классы и
        методы должны быть аннотированы с помощью <code>@abstract</code>. Не
        используйте <code>goog.abstractMethod</code>. См.
        <a
          href="https://github.com/google/closure-compiler/wiki/@abstract classes-and-methods"
          >абстрактные классы и методы</a
        >.
      </p>

      <h3 id="features-functions">5.5 Функции</h3>

      <h4 id="features-functions-top-level-functions">
        5.5.1 Функции верхнего уровня
      </h4>

      <p>
        Функции верхнего уровня могут быть определены непосредственно в объекте
        <code>exports</code>, или же объявлены локально и опционально
        экспортированы. Дополнительную информацию об экспорте см. в разделе
        <a href="#file-goog-module-exports">??</a>.
      </p>

      <p>Примеры:</p>

      <pre><code class="language-js prettyprint">/** @param {string} str */
exports.processString = (str) =&gt; {
  // Обработка строки.
};
</code></pre>

      <pre><code class="language-js prettyprint">/** @param {string} str */
const processString = (str) =&gt; {
  // Обработка строки
};</code></pre>

      <h4 id="features-functions-nested-functions">
        5.5.2 Вложенные функции и замыкания
      </h4>

      <p>
        Функции могут содержать вложенные определения функций. Если имеет смысл
        дать функции имя, функция должна быть присвоена локальной
        <code>const</code>.
      </p>

      <h4 id="features-functions-arrow-functions">5.5.3 Стрелочные функции</h4>

      <p>
        Стрелочные функции обеспечивают лаконичный синтаксис функций и упрощают
        поиск <code>this</code> для вложенных функций. Стрелочные функции более
        предпочтительны, чем ключевое слово <code>function</code>, особенно для
        вложенных функций (но см.
        <a href="#features-objects-method-shorthand">??</a>).
      </p>

      <p>
        Предпочтительнее использование стрелочных функций, чем других подходов
        для привязки <code>this</code> — такими как <code>f.bind(this)</code>,
        <code>goog.bind(f, this)</code> и <code>const self = this</code>.
        Стрелочные функции особенно полезны для вызова callback'ов, так как они
        позволяют явно указывать, какие параметры должны передаваться обратному
        вызову, в то время как привязка (binding) будет слепо передавать все
        параметры.
      </p>

      <p>
        Левая часть от стрелки содержит ноль или более параметров. Круглые
        скобки вокруг параметров являются необязательными, если есть только один
        недеструктурируемый параметр. При использовании круглых скобок можно
        указывать типы параметров (см.
        <a href="#jsdoc-method-and-function-comments">??</a>).
      </p>

      <p>
        Подсказка: постоянное использование круглых скобок даже для стрелочных
        функций с одним параметром позволяет избежать ситуаций, когда добавление
        параметров, но забывание добавлять скобки, может привести к коду,
        который парсится, но который больше не работает как задумано.
      </p>

      <p>
        В правой части от стрелки находится тело функции. По умолчанию тело -
        это блочный оператор (ноль или более операторов, окруженных фигурными
        скобками). Тело также может быть неявно возвращенным выражением, если:
        или логика программы требует возврата значения, или оператор
        <code>void</code> предшествует вызову одной функции или метода
        (использование <code>void</code> обеспечивает возврат
        <code>undefined</code>, предотвращает утечку значений и сообщает о
        намерении). Форма выражения предпочтительнее, если она улучшает
        читабельность (например, для коротких или простых выражений).
      </p>

      <p>Примеры:</p>

      <pre><code class="language-js prettyprint">/**
 * Стрелочная функция может быть задокументирована как обычная функция.
 * @param {number} numParam Число, которое нужно добавить
 * @param {string} strParam Еще одно число, которое нужно добавить
 * @return {number} Сумма двух параметров.
 */
const moduleLocalFunc = (numParam, strParam) =&gt; numParam + Number(strParam);

// Использует синтаксис выражения с `void`, потому что программная логика
// не требует возвращения значения.
getValue((result) =&gt; void alert(`Получено ${result}`));

class CallbackExample {
  constructor() {
    /** @private {number} */
    this.cachedValue_ = 0;

    // Для однострочных callback'ов, вы можете использовать определение типов для параметров.
    // Используется блочный оператор, потому что значение выражения не должно ничего
    // возвращать, и выражение не является единственным вызовом функции.
    getNullableValue((/** ?number */ result) =&gt; {
      this.cachedValue_ = result == null ? 0 : result;
    });
  }
}
</code></pre>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">/**
 * Функция без параметров и без возвращаемого значения.
 * Такое использование тела выражения недопустимо, поскольку логика программы
 * не требует возвращаемого значение, и нам не хватает оператора `void`.
 */
const moduleLocalFunc = () =&gt; anotherFunction();
</code></pre>

      <h4 id="features-functions-generators">5.5.4 Генераторы</h4>

      <p>
        Генераторы позволяют использовать ряд полезных абстракций и могут быть
        использованы по мере необходимости.
      </p>

      <p>
        При определении функций генератора допишите <code>*</code> к ключевому
        слову <code>function</code>, если оно присутствует, и отделите его
        пробелом от имени функции. При использовании делегированных yield
        допишите <code>*</code> к ключевому слову <code>yield</code>.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">/** @return {!Iterator&lt;number&gt;} */
function* gen1() {
  yield 42;
}

/** @return {!Iterator&lt;number&gt;} */
const gen2 = function*() {
  yield* gen1();
}

class SomeClass {
  /** @return {!Iterator&lt;number&gt;} */
  * gen() {
    yield 42;
  }
}
</code></pre>

      <h4 id="features-functions-parameter-return-types">
        5.5.5 Параметры и возвращаемые типы
      </h4>

      <p>
        Параметры функции и возвращаемые типы обычно должны быть
        задокументированы с помощью JSDoc аннотаций. Смотрите
        <a href="#jsdoc-method-and-function-comments">??</a> для получения
        дополнительной информации.
      </p>

      <h5 id="features-functions-default-parameters">
        5.5.5.1 Параметры по умолчанию
      </h5>

      <p>
        Допускается использование опциональных параметров с помощью оператора
        равенства в списке параметров. Опциональные параметры должны включать
        пробелы с обеих сторон оператора равенства, именоваться точно так же,
        как и требуемые параметры (т.е. не префиксоваться с помощью
        <code>opt_</code>), использовать суффикс <code>=</code> в их JSDoc-типе,
        идти после требуемых параметров и не использовать инициализаторы,
        которые создают заметные побочные эффекты. Все опциональные параметры
        для функций должны иметь значения по умолчанию, даже если это значение
        <code>undefined</code>. В отличие от обычных функций, абстрактный и
        интерфейсный методы должны опускать значения параметров по умолчанию.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">/**
 * @param {string} required Этот параметр необходим всегда
 * @param {string=} optional Этот параметр может быть опущен
 * @param {!Node=} node Другой опциональный параметр
 */
function maybeDoSomething(required, optional = '', node = undefined) {}

/** @interface */
class MyInterface {
  /**
   * Интерфейсные и абстрактные методы должны опускать значения параметров по умолчанию.
   * @param {string=} optional
   */
  someMethod(optional) {}
}
</code></pre>

      <p>
        Используйте параметры по умолчанию экономно. Предпочитается
        деструктурирование (как в
        <a href="#features-objects-destructuring">??</a>) для создания читаемого
        API, когда есть более чем один опциональный параметр, которые не имеют
        естественного порядка.
      </p>

      <p>
        Примечание: В отличие от параметров по умолчанию в Python, можно
        использовать инициализаторы, которые возвращают новые мутируемые объекты
        (такие как <code>{}</code> или <code>[]</code>), потому что
        инициализатор вычисляется каждый раз при использовании значения по
        умолчанию, поэтому один объект не будет совместно использоваться в
        нескольких вызовах.
      </p>

      <p>
        Подсказка: Хотя в качестве инициализаторов могут использоваться
        произвольные выражения, включая вызовы функций, их следует делать как
        можно более простыми. Избегайте инициализаторов, показывающих общее
        изменяемое состояние, так как это может легко привести к
        непреднамеренной связи между вызовами функций.
      </p>

      <h5 id="features-functions-rest-parameters">
        5.5.5.2 Остальные параметры
      </h5>

      <p>
        Используйте параметр <em>rest</em> вместо доступа к
        <code>arguments</code>. Оставшиеся параметры начинаются с префикса
        <code>...</code> в JSDoc. <code>rest</code> параметр должен быть
        последним в списке. Между <code>...</code> и именем параметра нет
        пробела. Не называйте параметр rest <code>var_args</code>. Никогда не
        называйте локальную переменную или параметр <code>arguments</code>, он
        вносит путаницу из-за встроенного arguments.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">/**
 * @param {!Array&lt;string&gt;} array Это обычный параметр.
 * @param {...number} numbers Все оставшиеся параметры являются числами.
 */
function variadic(array, ...numbers) {}
</code></pre>

      <h4 id="features-functions-generics">5.5.6 Обобщения</h4>

      <p>
        Объявите общие функции и методы, когда это необходимо, с помощью
        <code>@template TYPE</code> в JSDoc над определением функции или метода.
      </p>

      <h4 id="features-functions-spread-operator">5.5.7 Оператор расширения</h4>

      <p>
        Вызовы функций могут использовать оператор расширения
        (<code>...</code>). Предпочитайте оператор расширения перед
        <code>Function.prototype.apply</code> при распаковке массива или
        итерабельного метода в несколько параметров функции с вариативным
        количеством параметров. Пробел после <code>...</code> отсутствует.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">function myFunction(...elements) {}
myFunction(...array, ...iterable, ...generator());
</code></pre>

      <h3 id="features-string-literals">5.6 Строковые литералы</h3>

      <h4 id="features-strings-use-single-quotes">
        5.6.1 Используйте одиночные кавычки
      </h4>

      <p>
        Обычные строковые литералы разделяются одиночными кавычками
        (<code>'</code>), а не двойными кавычками (<code>"</code>).
      </p>

      <p>
        Подсказка: если строка содержит символ одиночной кавычки, рассмотрите
        возможность использования строки-шаблона, чтобы избежать необходимости
        экранирования кавычек.
      </p>

      <p>Обычные строковые литералы не могут охватывать несколько строк.</p>

      <h4 id="features-strings-template-strings">5.6.2 Шаблонные литералы</h4>

      <p>
        Используйте шаблонные литералы (разделенные <code>`</code>) со сложной
        конкатенацией строк, особенно если речь идет о многострочных литералах.
        Шаблонные литералы могут занимать несколько строк.
      </p>

      <p>
        Если шаблонный литерал охватывает несколько строк, ему не нужно
        поддерживать отступ блока (хотя это возможно, если добавленные
        пробельные символы не имеют значения).
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">function arithmetic(a, b) {
  return `Это таблица с арифметическими операторами:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
</code></pre>

      <h4 id="features-strings-no-line-continuations">
        5.6.3 Не используйте продолжения строк
      </h4>

      <p>
        Не используйте <em>продолжения строк</em> (то есть завершение строки
        внутри строкового литерала обратным слешем) ни в обычных, ни в шаблонных
        строковых литералах. Хотя ES5 позволяет это, это может привести к
        неожиданным ошибкам, если любой пробельный символ стоит после косой
        черты — к тому же, он является менее очевидным для читателей.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">const longString = 'Это очень длинная строка, которая превышает лимит в \
    80 символов. К сожалению, она содержит длинные отрезки пустого пространства, так \
    как в продолженных строках имеются отступы для поддержания форматирования.';
</code></pre>

      <p>Вместо этого напишите</p>

      <pre><code class="language-js prettyprint">const longString = 'Это очень длинная строка, которая превышает лимит в ' +
    '80 символов. Она не содержит длинные отрезки пустого пространства, поскольку ' +
    'конкатенируемые строки не имеют в себе лишних отступов.';
</code></pre>

      <h3 id="features-number-literals">5.7 Числовые литералы</h3>

      <p>
        Числа могут быть указаны в десятичной, шестнадцатеричной, восьмеричной
        или двоичной форме. Используйте точные префиксы <code>0x</code>,
        <code>0o</code> и <code>0b</code> со строчными буквами для
        шестнадцатеричных, восьмеричных и двоичных форм соответственно. Никогда
        не включайте ведущий ноль, если за ним не следуют <code>x</code>,
        <code>o</code> или <code>b</code>.
      </p>

      <h3 id="features-control-structures">5.8 Управляющие циклы</h3>

      <h4 id="features-for-loops">5.8.1 Для циклов</h4>

      <p>
        В ES6 язык теперь имеет три различных типа циклов <code>for</code>. Все
        они могут использоваться, хотя <code>for</code>-<code>of</code> цикл
        должен быть в приоритете, когда это возможно.
      </p>

      <p>
        <code>for</code>-<code>in</code> циклы можно использовать только для
        объектов в dict стиле (см.
        <a href="#features-objects-mixing-клавиши">??</a>), и их не следует
        использовать для итераций по массиву.
        <code>Object.prototype.hasOwnProperty</code> следует использовать в
        <code>for</code>-<code>in</code> циклах для исключения нежелательных
        свойств прототипа. Предпочтите <code>for</code>-<code>of</code> и
        <code>Object.keys</code>, чем <code>for</code>-<code>in</code>, когда
        это возможно.
      </p>

      <h4 id="features-exceptions">5.8.2 Исключения</h4>

      <p>
        Исключения являются важной частью языка и должны использоваться всякий
        раз, когда возникают исключительные случаи. Всегда бросайте
        <code>Error</code> или подклассы <code>Error</code>: никогда не
        выбрасывайте строковые литералы или другие объекты. Всегда используйте
        <code>new</code> при построении <code>Error</code>.
      </p>

      <p>
        Эта обработка распространяется на значения <code>Promise</code>
        <code>rejection()</code> , поскольку
        <code>Promise.rejection(obj)</code> эквивалентно
        <code>throw obj;</code> в асинхронных функциях.
      </p>

      <p>
        Пользовательские исключения обеспечивают отличный способ передачи
        дополнительной информации об ошибках из функций. Они должны быть
        определены и использованы везде, где родной тип
        <code>Error</code> недостаточен.
      </p>

      <p>
        Предпочтение отдается выбрасыванию исключений, а не специальным подходам
        к обработке ошибок (таким как передача ссылки на тип контейнера ошибки
        или возврат объекта со свойством ошибки).
      </p>

      <h5 id="features-empty-catch-blocks">5.8.2.1 Пустые catch блоки</h5>

      <p>
        Очень редко корректно ничего не делать в ответ на пойманное исключение.
        Когда действительно уместно не предпринимать никаких действий в блоке
        catch, причина, по которой это оправдано, объясняется в комментариях.
      </p>

      <pre><code class="language-js prettyprint">try {
  return handleNumericResponse(response);
} catch (ok) {
  // это не число; это нормально — продолжаем работу
}
return handleTextResponse(response);
</code></pre>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">  try {
    shouldFail();
    fail('ожидается ошибка');
  } catch (expected) {
  }
</code></pre>

      <p>
        Совет: В отличие от некоторых других языков, шаблоны, подобные
        вышеприведенным, просто не работают, так как они будут ловить ошибку,
        брошенную с помощью <code>fail</code>. Вместо этого используйте
        <code>assertThrows()</code>.
      </p>

      <h4 id="features-switch-statements">5.8.3 Switch оператор</h4>

      <p>
        Терминологическое примечание: Внутри фигурных скобок блока switch
        находятся одна или несколько групп операторов. Каждая группа операторов
        состоит из одной или нескольких блоков switch (либо
        <code>case FOO:</code> или <code>default:</code>), за которыми следует
        один или несколько операторов.
      </p>

      <h5 id="features-switch-fall-through">
        5.8.3.1 Пропуски вниз: должны комментироваться
      </h5>

      <p>
        Внутри блока switch каждая группа операторов либо прерывается внезапно
        (с помощью <code>break</code>, <code>return</code> или
        <code>throw</code>), либо помечается комментарием, указывающим на то,
        что выполнение будет или может быть продолжено в следующей группе
        операторов. Достаточно любого комментария, который передает идею
        продолжения (обычно пишется <code>// fall through</code>). Этот
        специальный комментарий не требуется в последней группе операторов в
        блоке switch.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
    // fall through (продолжение)
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</code></pre>

      <h5 id="features-switch-default-case">
        5.8.3.2 Блок <code>default</code> должен присутствовать
      </h5>

      <p>
        Каждый оператор switch включает оператор
        <code>default</code>, даже если он не содержит кода. Оператор
        <code>default</code> должен быть последним.
      </p>

      <h3 id="features-this">5.9 this</h3>

      <p>
        Используйте <code>this</code> только в конструкторах и методах класса, в
        стрелочных функциях, определенных внутри конструкторов и методов класса,
        или в функциях, которые имеют явный <code>@this</code>, объявленный в
        JSDoc, а также в функциях, которые сразу закрываются.
      </p>

      <p>
        Никогда не используйте <code>this</code> для обращения к глобальному
        объекту, контексту <code>eval</code>, <code>target</code> принадлежащему
        <code>event</code>, или ненужному <code>call()</code> или
        <code>apply()</code> функций.
      </p>

      <h3 id="features-equality-checks">5.10 Проверка равенства</h3>

      <p>
        Используйте операторы сравнения (<code>===</code>/<code>!==</code>), за
        исключением случаев, описанных ниже.
      </p>

      <h4 id="features-equality-checks-exceptions">
        5.10.1 Исключения, где необходимо приведение типов
      </h4>

      <p>
        Поимка с помощью <code>catch</code> обоих значений <code>null</code> и
        <code>undefined</code>:
      </p>

      <pre><code class="language-js prettyprint">if (someObjectOrPrimitive == null) {
  // Проверка на наличие null ловит и null, и undefined для объектов и
  // примитивов, но не ловит другие неправильные значения, как 0 или пустые
  // строки.
}
</code></pre>

      <h3 id="disallowed-features">5.11 Запрещенные возможности</h3>

      <h4 id="disallowed-features-with">5.11.1 with</h4>

      <p>
        Не используйте ключевое слово <code>with</code>. Это сделает ваш код
        более трудным для понимания. К тому же он запрещен в строгом режиме со
        времен ES5.
      </p>

      <h4 id="disallowed-features-dynamic-code-evaluation">
        5.11.2 Динамическая оценка кода
      </h4>

      <p>
        Не используйте <code>eval</code> для конструктора
        <code>Function(...string)</code> (за исключением загрузчиков кода). Эти
        возможности потенциально опасны и просто не работают в среде CSP
        (политики защиты контента).
      </p>

      <h4 id="disallowed-features-automatic-semicolon-insertion">
        5.11.3 Автоматическая установка точки с запятой
      </h4>

      <p>
        Всегда завершайте выражения точкой с запятой (за исключением объявлений
        функций и классов, как было отмечено выше).
      </p>

      <h4 id="disallowed-features-non-standard-features">
        5.11.4 Нестандартные функции
      </h4>

      <p>
        Не используйте нестандартные функции. Сюда относятся старые функции,
        которые были удалены (например, <code>WeakMap.clear</code>), новые
        функции, которые еще не стандартизованы (например, текущий рабочий
        проект TC39, предложения на любом этапе, или предлагаемые, но не
        исчерпывающие веб-стандарты), или проприетарные функции, которые
        реализованы только в некоторых браузерах. Используйте только те функции,
        которые определены в текущих стандартах ECMA-262 или WHATWG. (Обратите
        внимание, что проекты, настаивающие против определенных API, такие как
        расширения Chrome или Node.js, очевидно, могут использовать эти API).
        Нестандартный языковые расширения (например, предоставляемые некоторыми
        внешними транспайлерами — source-to-source компиляторами) запрещены.
      </p>

      <h4 id="disallowed-features-wrapper-objects">
        5.11.5 Объекты-обёртки для примитивных типов
      </h4>

      <p>
        Никогда не используйте <code>new</code> на обертках примитивных объектов
        (<code>Boolean</code>, <code>Number</code>, <code>String</code>,
        <code>Symbol</code>), а также не включайте их в аннотации к типам.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">const /** Boolean */ x = new Boolean(false);
if (x) alert(typeof x);  // отобразить 'object'... — какого типа?
</code></pre>

      <p>
        Обертки могут вызываться как функции для приведения типов (что
        предпочтительнее, чем использование <code>+</code> или конкатенация
        пустой строки) или создания символов.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">const /** boolean */ x = Boolean(0);
if (!x) alert(typeof x);  // отобразить 'boolean', как ожидается
</code></pre>

      <h4 id="disallowed-features-modifying-builtin-objects">
        5.11.6 Модификация встроенных объектов
      </h4>

      <p>
        Никогда не модифицируйте встроенные типы, добавляя методы в свои
        конструкторы или прототипы. Избегайте зависимости от библиотек, которые
        это делают. Обратите внимание, что библиотека исполнения JSCompiler'a по
        возможности предоставляет полифиллеры (преобразуют новый код в
        поддерживаемый старыми браузерами), соответствующие стандартам; больше
        ничто не должно модифицировать встроенные объекты.
      </p>

      <p>
        Не добавляйте символы в глобальный объект, если только это не является
        абсолютно необходимым (например, требуется сторонним API).
      </p>

      <h4 id="disallowed-features-omitting-parents-with-new">
        5.11.7 Опускание <code>()</code>, когда вызываете конструктор
      </h4>

      <p>
        Никогда не вызывайте конструктор с оператором <code>new</code> без
        использования скобок <code>()</code>.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">new Foo;</code></pre>

      <p>Используйте вместо этого:</p>

      <pre><code class="language-js prettyprint">new Foo();</code></pre>

      <p>
        Опущенные скобки могут привести к едва уловимым ошибкам. Эти две строки
        не эквивалентны:
      </p>

      <pre><code class="language-js prettyprint">new Foo().Bar();
new Foo.Bar();</code></pre>

      <h2 id="naming">6 Именование</h2>

      <h3 id="naming-rules-common-to-all-identifiers">
        6.1 Общие для всех идентификаторов правила
      </h3>

      <p>
        Идентификаторы используют только ASCII-буквы и цифры, и в небольшом
        количестве случаев, отмеченных ниже, подчеркивания и очень редко (когда
        этого требуют такие фреймворки, как Angular) знаки доллара.
      </p>

      <p>
        Давайте как можно более описательное название (в пределах разумного). Не
        беспокойтесь об экономии горизонтального пространства, т.к. гораздо
        важнее сделать свой код сразу же понятным для нового читателя. Не
        используйте аббревиатуры, которые являются двусмысленными или
        незнакомыми для читателей вне Вашего проекта, и не сокращайте, удаляя
        буквы внутри слова.
      </p>

      <pre><code class="language-js prettyprint">errorCount          // Без аббревиатуры.
dnsConnectionIndex  // Большинство людей знает, что такое "DNS".
referrerUrl         // То же самое для "URL".
customerId          // "Id" используется везде, поэтому вряд ли будет неправильно понят.
</code></pre>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">n                   // Бессмысленный.
nErr                // Двусмысленная аббревиатура.
nCompConns          // Двусмысленная аббревиатура.
wgcConnections      // Только ваша команда знает, что это значит.
pcReader            // Многие вещи можно назвать как "pc".
cstmrId             // Удалены внутренние символы.
kSecondsPerDay      // Не используйте венгерскую нотацию.
</code></pre>

      <h3 id="naming-rules-by-identifier-type">
        6.2 Правила для типов идентификатора
      </h3>

      <h4 id="naming-package-names">6.2.1 Именование пакетов</h4>

      <p>
        Имена всех пакетов должны быть в <code>lowerCamelCase</code>. Например,
        <code>my.exampleCode.deepSpace</code>, но не
        <code class="badcode">my.examplecode.deepspace</code> или
        <code class="badcode">my.example_code.deep_space</code>.
      </p>

      <h4 id="naming-class-names">6.2.2 Имена классов</h4>

      <p>
        Имена классов, интерфейсов, записей и typedef'ов записываются в
        <code>UpperCamelCase</code>. Неэкспортируемые классы являются просто
        локальными: они не помечаются как <code>@private</code> и не
        заканчиваются завершающим подчеркиванием.
      </p>

      <p>
        Имена типов обычно представляют собой существительные или фразы
        существительных. Например, <code>Request</code>,
        <code>ImmutableList</code> или <code>VisibilityMode</code>. Кроме того,
        имена интерфейсов иногда могут быть прилагательными или прилагательными
        фразами (например, <code>Readable</code>).
      </p>

      <h4 id="naming-method-names">6.2.3 Именование методов</h4>

      <p>
        Имена методов записываются в <code>lowerCamelCase</code>. Имена методов
        <code>@private</code> должны заканчиваться завершающим подчеркиванием.
      </p>

      <p>
        Имена методов обычно представляют собой глаголы или глагольные фразы.
        Например, <code>sendMessage</code> или <code>stop_</code>. Методы getter
        и setter для свойств никогда не требуются, но если они используются, то
        они должны быть названы <code>getFoo</code> (или опционально
        <code>isFoo</code> или <code>hasFoo</code> для booleans) или
        <code>setFoo(value)</code> для setters.
      </p>

      <p>
        Подчёркивания могут также появляться в именах методов тестирования
        JsUnit для разделения логических компонентов имени. Одним из типичных
        паттернов является
        <code
          >test&lt;MethodUnderTest&gt;_&lt;state&gt;_&lt;expectedOutcome&gt;</code
        >, например <code>testPop_emptyStack_throws</code>. Нет единого
        правильного способа называть методы для тестирования.
      </p>

      <h4 id="naming-enum-names">6.2.4 Имена перечислений</h4>

      <p>
        Имена перечислений записываются в <code>UpperCamelCase</code>,
        аналогично классам, и обычно должны быть единичными существительными.
        Отдельные элементы внутри перечисления именуются в
        <code>CONSTANT_CASE</code>.
      </p>

      <h4 id="naming-constant-names">6.2.5 Именование констант</h4>

      <p>
        Константы используют <code>CONSTANT_CASE</code>: все заглавные буквы,
        слова разделены подчеркиванием. Нет причин для именования констант с
        завершающим подчеркиванием, так как приватные статические свойства
        могут быть заменены (неявно приватными) локальными модулями.
      </p>

      <h5 id="naming-definition-of-constant">
        6.2.5.1 Определение &#8220;constant&#8221;
      </h5>

      <p>
        Каждая константа представляет собой статическое свойство
        <code>@const</code> или модульно-локальные
        <code>const</code> объявления, но не все <code>@const</code> — это
        статические свойства, а модульно-локальные <code>const</code> — являются
        константами. Перед тем, как выбрать константный регистр, подумайте,
        действительно ли поле похоже на <em>глубоко неизменяемую</em> константу.
        Например, если какое-либо из наблюдаемых состояний этого экземпляра
        может измениться, то это почти наверняка не константа. Простого
        намерения никогда не изменять объект, как правило, недостаточно.
      </p>

      <p>Примеры:</p>

      <pre><code class="language-js prettyprint">// Константы
const NUMBER = 5;
/** @const */ exports.NAMES = ImmutableList.of('Ed', 'Ann');
/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };

// Не константы
let letVariable = 'non-const';
class MyClass { constructor() { /** @const {string} */ this.nonStatic = 'non-static'; } };
/** @type {string} */ MyClass.staticButMutable = 'не @const, может быть переопределено';
const /** Set&lt;string&gt; */ mutableCollection = new Set();
const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);
const Foo = goog.require('my.Foo');  // зеркально импортируемое имя
const logger = log.getLogger('loggers.are.not.immutable');
</code></pre>

      <p>
        Имена констант обычно представляют собой существительные или
        существительные фразы.
      </p>

      <h5 id="naming-local-aliases">6.2.5.2 Локальные псевдонимы</h5>

      <p>
        Локальные псевдонимы следует использовать всякий раз, когда они улучшают
        читабельность по сравнению с полноразмерными именами. Следуйте тем же
        правилам, что и <code>goog.require</code> (<a href="#file-goog-require"
          >??</a
        >), сохраняя последнюю часть псевдонима. Псевдонимы также могут
        использоваться внутри функций. Псевдонимы должны быть
        <code>const</code>.
      </p>

      <p>Примеры:</p>

      <pre><code class="language-js prettyprint">const staticHelper = importedNamespace.staticHelper;
const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;
const {assert, assertInstanceof} = asserts;
</code></pre>

      <h4 id="naming-non-constant-field-names">
        6.2.6 Неконсатные названия полей
      </h4>

      <p>
        Неконстантные имена полей (статические или иные) записываются в
        <code>lowerCamelCase</code>, с завершающимися подчеркиванием для
        приватных полей.
      </p>

      <p>
        Эти имена обычно являются существительными или фразами существительных.
        Например, <code>computedValues</code> или <code>index_</code>.
      </p>

      <h4 id="naming-parameter-names">6.2.7 Имена параметров</h4>

      <p>
        Имена параметров записываются в <code>lowerCamelCase</code>. Обратите
        внимание, что это применимо, даже если параметр ожидает конструктор.
      </p>

      <p>
        Односимвольные имена параметров не должны использоваться в публичных
        методах.
      </p>

      <p>
        <strong>Исключение</strong>: По требованию стороннего фреймворка имена
        параметров могут начинаться с <code>$</code>. Это исключение не
        распространяется на любые другие идентификаторы (например, локальные
        переменные или свойства).
      </p>

      <h4 id="naming-local-variable-names">
        6.2.8 Именование локальных переменных
      </h4>

      <p>
        Имена локальных переменных записываются в <code>lowerCamelCase</code>,
        за исключением модульно-локальных (верхнего уровня) констант, как
        описано выше. Имена констант в функциональных областях по-прежнему
        написаны в <code>lowerCamelCase</code>. Обратите внимание, что
        <code>lowerCamelCase</code> используется, даже если переменная содержит
        конструктор.
      </p>

      <h4 id="naming-template-parameter-names">
        6.2.9 Имена параметров шаблона
      </h4>

      <p>
        Имена параметров шаблона должны быть краткими, однозначными или
        однобуквенными идентификаторами, и должны быть в ВЕРХНЕМ РЕГИСТРЕ,
        например
        <code>TYPE</code> или <code>THIS</code>.
      </p>

      <h4 id="naming-module-local-names">6.2.10 Модульно-локальные имена</h4>

      <p>
        Имена в модулях, которые не экспортируются, являются неявно закрытыми.
        Они не помечены <code>@private</code> и не заканчиваются подчеркиванием.
        Это относится к классам, функциям, переменным, константам, перечислениям
        и другим модульно-локальным идентификаторам.
      </p>

      <h3 id="naming-camel-case-defined">
        6.3 Верблюжий стиль: отдельный случай
      </h3>

      <p>
        Иногда существует более одного разумного способа преобразования
        английской фразы в верблюжий стиль, например, когда присутствуют
        аббревиатуры или необычные конструкции вроде <q>IPv6</q> или <q>iOS</q>.
        Для повышения предсказуемости Google Style задает следующую
        исчерпывающую (почти) схему.
      </p>

      <p>Начиная с изначальной формы имени:</p>

      <ol>
        <li>
          Преобразуйте фразу в обычный ASCII и удалите все апострофы. Например,
          <q>M&#252;ller's algorithm</q> может стать <q>Muellers algorithm</q>.
        </li>
        <li>
          Разделите этот результат на слова, разделяя их на пробелы и оставшиеся
          знаки препинания (обычно дефисы).
          <ol>
            <li>
              Рекомендовано: если какое-либо слово уже имеет общепринятый
              внешний вид в camelCase, разделите его на составные части
              (например, AdWords становится "ad words"). Обратите внимание, что
              такое слово, как iOS, на самом деле, не совсем в camelCase; оно не
              поддается никаким соглашениям, поэтому данная рекомендация не
              применяется.
            </li>
          </ol>
        </li>
        <li>
          Теперь сделайте все буквы в нижнем регистре (включая аббревиатуры),
          затем сделайте в верхнем регистре только первый символ:
          <ol>
            <li>
              &#8230; каждого слова (чтобы вышел CamelCase в верхнем регистре)
              или
            </li>
            <li>
              &#8230; каждого слова, кроме первого (чтобы вышел camelCase в
              нижнем регистре)
            </li>
          </ol>
        </li>
        <li>В конце, соедините все слова в один идентификатор.</li>
      </ol>

      <p>
        Обратите внимание, что регистр исходных слов почти полностью
        игнорируется.
      </p>

      <p>Примеры:</p>

      <table>
        <thead>
          <tr>
            <th style="text-align: center">Изначальная форма</th>
            <th style="text-align: center">Корректно</th>
            <th style="text-align: center">Некорректно</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="text-align: center"><q>XML HTTP request</q></td>
            <td style="text-align: center">XmlHttpRequest</td>
            <td style="text-align: center">XMLHTTPRequest</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>new customer ID</q></td>
            <td style="text-align: center">newCustomerId</td>
            <td style="text-align: center">newCustomerID</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>inner stopwatch</q></td>
            <td style="text-align: center">innerStopwatch</td>
            <td style="text-align: center">innerStopWatch</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>supports IPv6 on iOS?</q></td>
            <td style="text-align: center">supportsIpv6OnIos</td>
            <td style="text-align: center">supportsIPv6OnIOS</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>YouTube importer</q></td>
            <td style="text-align: center">YouTubeImporter</td>
            <td style="text-align: center">YoutubeImporter*</td>
          </tr>
        </tbody>
      </table>

      <p>*Приемлемо, но не рекомендуется.</p>

      <p>
        Примечание: некоторые слова неоднозначны в английском языке: например,
        <q>nonempty</q> и <q>non-empty</q> оба правильны, поэтому имена методов
        checkNonempty и checkNonEmpty также правильны.
      </p>

      <h2 id="jsdoc">7 JSDoc</h2>

      <p>
        <a
          href="https://developers.google.com/closure/compiler/docs/js-for-compiler"
          >JSDoc</a
        >
        используется для всех классов, полей и методов.
      </p>

      <h3 id="jsdoc-general-form">7.1 Общая форма</h3>

      <p>Основной вид форматирования блоков JSDoc показан в этом примере:</p>

      <pre><code class="language-js prettyprint">/**
 * Несколько линий текста JSDoc написаны здесь.
 * Строки переносятся, как обычно.
 * @param {number} arg Число, чтобы делать что-то.
 */
function doSomething(arg) { &#8230; }
</code></pre>

      <p>или в этом однострочном примере:</p>

      <pre><code class="language-js prettyprint">/** @const @private {!Foo} Чуть меньше JSDoc. */
this.foo_ = foo;
</code></pre>

      <p>
        Если однострочный комментарий переносится на несколько строк, он должен
        использовать многострочный стиль с <code>/**</code> и <code>*/</code> в
        своих строках.
      </p>

      <p>
        Многие инструменты извлекают метаданные из комментариев JSDoc для
        выполнения валидации и оптимизации кода. Поэтому эти комментарии
        <strong>должны</strong> быть хорошо сформированы.
      </p>

      <h3 id="jsdoc-markdown">7.2 Markdown</h3>

      <p>
        JSDoc написан на языке Markdown, хотя при необходимости может включать
        HTML.
      </p>

      <p>
        Обратите внимание, что инструменты, которые автоматически извлекают
        JSDoc (например,
        <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) часто
        игнорируют форматирование обычного текста, так что если вы сделаете так:
      </p>

      <pre><code class="language-js prettyprint badcode">/**
 * Вычисляет вес на основе трех факторов:
 *   элементов отправлено
 *   элементов получено
 *   последняя временная метка
 */
</code></pre>

      <p>это станет таким:</p>

      <pre><code>Вычисляет вес на основе трех факторов: элементов отправлено элементов получено последная временная метка</code></pre>

      <p>Вместо этого напишите список Markdown:</p>

      <pre><code class="language-js prettyprint badcode">/**
 * Вычисляет вес на основе трех факторов:
 *  - элементов отправлено
 *  - элементов получено
 *  - последняя временная метка
 */
</code></pre>

      <h3 id="jsdoc-tags">7.3 JSDoc теги</h3>

      <p>
        Стиль Google разрешает подмножество JSDoc-тегов. См.
        <a href="#appendices-jsdoc-tag-reference">??</a> для полного списка.
        Большинство тегов должны занимать свою собственную строку, с тегом в
        начале строки.
      </p>

      <p>Запрещено:</p>

      <pre><code class="language-js prettyprint badcode">/**
 * Тэг "param" должен занимать свою собственную строку и не может комбинироваться.
 * @param {number} left @param {number} right
 */
function add(left, right) { ... }
</code></pre>

      <p>
        Простые теги, не требующие дополнительных данных (такие, как
        <code>@private</code>, <code>@const</code>, <code>@final</code>,
        <code>@export</code>), могут быть объединены в одну строку вместе с
        дополнительным типом, если это необходимо.
      </p>

      <pre><code class="language-js prettyprint">/**
 * Размещайте более сложные аннотации (например, "implements" и "template").
 * на своих отдельных линиях.  Несколько простых тегов (например, "export" и "final").
 * могут быть скомбинированы в одной линии.
 * @export @final
 * @implements {Iterable&lt;TYPE&gt;}
 * @template TYPE
 */
class MyClass {
  /**
   * @param {!ObjType} obj Отдельный объект.
   * @param {number=} num Опциональное число.
   */
  constructor(obj, num = 42) {
    /** @private @const {!Array&lt;!ObjType|number&gt;} */
    this.data_ = [obj, num];
  }
}
</code></pre>

      <p>
        Не существует точного правила, когда и в каком порядке комбинировать
        теги, но будьте последовательным.
      </p>

      <p>
        Общую информацию об аннотировании типов в JavaScript см. в разделе
        <a
          href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler"
          >Аннотирование JavaScript для Closure Compiler</a
        >
        и
        <a
          href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System"
          >Типы в Closure Type System</a
        >.
      </p>

      <h3 id="jsdoc-line-wrapping">7.4 Перенос строк</h3>

      <p>
        Перенесенные теги имеют отступы в четыре пробела. Перенесенный текст
        описания может быть выровнен с описанием в предыдущих строках, но такое
        выравнивание по горизонтали не рекомендуется.
      </p>

      <pre><code class="language-js prettyprint">/**
 * Иллюстрирует перенос строки для длинных описаний.
 * @param {string} foo Это параметр с описанием, слишком длинным, чтобы 
 *     быть в одной строке.
 * @return {number} Это параметр с описанием, слишком длинным, чтобы 
 *     быть в одной строке.
 */
exports.method = function(foo) {
  return 5;
};
</code></pre>

      <p>
        Не делайте отступы при переносе описания <code>@desc</code> или
        <code>@fileoverview</code>.
      </p>

      <h3 id="jsdoc-top-file-level-comments">
        7.5 Комментарии верхнего\файлового уровня
      </h3>

      <p>
        Файл может иметь описание верхнего уровня. Уведомление об авторском
        праве, информация об авторе и
        <a href="#jsdoc-visibility-annotations">уровень видимости</a> по
        умолчанию являются необязательными. Общее описание файлов обычно
        рекомендуется, когда файл состоит из более чем одного определения
        класса. Комментарий верхнего уровня предназначен для того, чтобы
        сориентировать читателей, незнакомых с кодом, на то, что находится в
        этом файле. Если он присутствует, он может предоставить описание
        содержимого файла и информацию о любых зависимостях или совместимости.
        Перенесенные строки не имеют отступов.
      </p>

      <p>Пример:</p>

      <pre><code class="language-js prettyprint">/**
 * @fileoverview Описание файла, цели его использование и информация
 * о его зависимостях.
 * @package
 */
</code></pre>

      <h3 id="jsdoc-class-comments">7.6 Комментарии класса</h3>
      <p>
        Классы, интерфейсы и записи должны быть задокументированы описанием и
        любыми параметрами шаблона, реализованными интерфейсами, видимостью или
        другими соответствующими тегами. Описание класса должно давать читателю
        достаточно информации, чтобы знать, как и когда использовать класс, а
        также любые дополнительные моменты, необходимые для корректного
        использования класса. Текстовые описания могут быть опущены в
        конструкторе. <code>@constructor</code> и
        <code>@extends </code> аннотации не используются с ключевым словом
        <code>class</code>, если только класс не используется для объявления
        <code>@interface </code> или не расширяет общий класс.
      </p>

      <pre><code class="language-js prettyprint">/**
 * Особенная цель события, которая делает полезные вещи.
 * @implements {Iterable&lt;string&gt;}
 */
class MyFancyTarget extends EventTarget {
  /**
   * @param {string} arg1 Аргумент, который делает это более полезным.
   * @param {!Array&lt;number&gt;} arg2 Список чисел для обработки.
   */
  constructor(arg1, arg2) {
    // ...
  }
};

/**
 * Записи также полезны.
 * @extends {Iterator&lt;TYPE&gt;}
 * @record
 * @template TYPE
 */
class Listable {
  /** @return {TYPE} Следующий элемент в строке, который будет возвращен. */
  next() {}
}
</code></pre>

      <h3 id="jsdoc-enum-and-typedef-comments">
        7.7 Комментарии перечисления и typedef
      </h3>

      <p>
        Все перечисления и typedefs должны быть задокументированы с помощью
        соответствующих тегов JSDoc (<code>@typedef</code> или
        <code>@enum</code>) на предшествующей строке. Публичные перечисления и
        typedefs также должны иметь описание. Отдельные элементы перечисления
        могут быть задокументированы JSDoc комментарием на предшествующей
        строке.
      </p>

      <pre><code class="language-js prettyprint">/**
 * Полезное объединение типа, которое часто используется повторно.
 * @typedef {!Bandersnatch|!BandersnatchType}
 */
let CoolUnionType;


/**
 * Типы бандерснатчей.
 * @enum {string}
 */
const BandersnatchType = {
  /** Этот вид действительно странный */
  FRUMIOUS: 'frumious',
  /** Менее важный тип */
  MANXOME: 'manxome',
};
</code></pre>

      <p>
        Typedefs полезны для определения типов коротких записей или псевдонимов
        для объединений, сложных функций или общих типов. Следует избегать
        typedefs'ов для типов записей с большим количеством полей, поскольку они
        не позволяют документировать отдельные поля, а также использовать
        шаблоны или рекурсивные ссылки. Для больших типов записей предпочитайте
        <code>@record</code>.
      </p>

      <h3 id="jsdoc-method-and-function-comments">
        7.8 Комментарии методов и функций
      </h3>

      <p>
        В методах и именованных функциях должны документироваться типы
        параметров и возвращаемого значения, за исключением случая одинаковой
        подписи
        <code>@override</code>, где опущены все типы. Тип
        <code>this</code> должен быть документирован при необходимости.
        Возвращаемый тип может быть опущен, если функция не имеет непустых
        выражений <code>return</code>.
      </p>

      <p>
        Описания метода, параметров и возвращаемых значений (но не типов) могут
        быть опущены, если они очевидны из остальной части JSDoc'a метода или из
        его определения.
      </p>

      <p>
        Описание метода начинается с глагольной фразы, описывающей, что делает
        метод. Эта фраза не является обязательным предложением, а написана в
        третьем лице, как будто подразумевается <q>Этот метод ...</q>.
      </p>

      <p>
        Если метод переопределяет метод суперкласса, он должен включать в себя
        примечание <code>@override</code>. Переопределенные методы наследуют все
        аннотации JSDoc от метода суперкласса (включая аннотации видимости) и
        должны быть опущены в переопределенном методе. Однако, если в аннотациях
        типа какой-либо тип уточнен, все <code>@param</code> и
        <code>@return</code> аннотации должны быть указаны явно.
      </p>

      <pre><code class="language-js prettyprint">/** Класс, который что-то делает. */
class SomeClass extends SomeBaseClass {
  /**
   * Взаимодействует с экземпляром MyClass и что-то возвращает.
   * @param {!MyClass} obj Объект, который по какой-то причине требует детального
   *     описания, которое занимает несколько строк.
   * @param {!OtherClass} obviousOtherClass
   * @return {boolean} Если что-то произошло.
   */
  someMethod(obj, obviousOtherClass) { ... }

  /** @override */
  overriddenMethod(param) { ... }
}

/**
 * Демонстрирует, как функции верхнего уровня следуют тем же правилам. Данная функция
 * создает массив.
 * @param {TYPE} arg
 * @return {!Array&lt;TYPE&gt;}
 * @template TYPE
 */
function makeArray(arg) { ... }
</code></pre>

      <p>
        Если необходимо только документировать параметры и возвращаемые типы
        функции, можно дополнительно использовать встроенные JSDocs в сигнатуре
        функции. Эти встроенные JSDoc'и определяют типы возвращаемого значения и
        параметров без тегов.
      </p>

      <pre><code class="language-js prettyprint">function /** string */ foo(/** number */ arg) {...}
</code></pre>

      <p>
        Если вам нужно описание или теги, используйте один JSDoc комментарий над
        методом. Например, методы, возвращающие значения, должны иметь тег
        <code>@return</code>.
      </p>

      <pre><code class="language-js prettyprint">class MyClass {
  /**
   * @param {number} arg
   * @return {string}
   */
  bar(arg) {...}
}
</code></pre>

      <pre><code class="language-js prettyprint badcode">// Недопустимый однострочный JSDoc.

class MyClass {
  /** @return {string} */ foo() {...}
}

/** Function description. */ bar() {...}
</code></pre>

      <p>
        В анонимных функциях аннотации, как правило, являются необязательными.
        Если автоматический вывод типа недостаточен или явная аннотация улучшает
        читабельность, то аннотируйте параметры и возвращаемые типы, как это
        делается здесь:
      </p>

      <pre><code class="language-js prettyprint">promise.then(
    /** @return {string} */
    (/** !Array&lt;string&gt; */ items) =&gt; {
      doSomethingWith(items);
      return items[0];
    });
</code></pre>

      <p>
        Для функциональных выражений, см.
        <a href="#jsdoc-function-types">??</a>.
      </p>

      <h3 id="jsdoc-property-comments">7.9 Комментарии параметров</h3>

      <p>
        Типы свойств должны быть документированы. Описание может быть опущено
        для некоторых свойств, если имя и тип предоставляют достаточно
        документации для понимания кода.
      </p>

      <p>
        Публично экспортируемые константы комментируются так же, как и свойства.
      </p>

      <pre><code class="language-js prettyprint">/** My class. */
class MyClass {
  /** @param {string=} someString */
  constructor(someString = 'default string') {
    /** @private @const {string} */
    this.someString_ = someString;

    /** @private @const {!OtherType} */
    this.someOtherThing_ = functionThatReturnsAThing();

    /**
     * Максимальное количество вещей на панели.
     * @type {number}
     */
    this.someProperty = 4;
  }
}

/**
 * Сколько раз мы попробуем, прежде чем прекратить.
 * @const {number}
 */
MyClass.RETRY_COUNT = 33;
</code></pre>

      <h3 id="jsdoc-type-annotations">7.10 Аннотации типа</h3>

      <p>
        Аннотации типов находятся в тегах <code>@param</code>,
        <code>@return</code>, <code>@this</code> и <code>@type</code>, и
        опционально в тегах <code>@const</code>, <code>@export</code> и на любых
        тегах видимости. Аннотации типа, прикрепленные к тегам JSDoc, всегда
        должны быть заключены в фигурные скобки.
      </p>

      <h4 id="jsdoc-nullability">7.10.1 Nullability</h4>

      <p>
        Система типов определяет модификаторы <code>!</code> и
        <code>?</code> для ненулевых и нулевых соответственно. Эти модификаторы
        должны предшествовать типу.
      </p>

      <p>
        Модификаторы Nullability имеют различные требования к различным типам,
        которые делятся на две категории:
      </p>

      <ol>
        <li>
          Аннотации типов для примитивов (<code>string</code>,
          <code>number</code>, <code>boolean</code>, <code>symbol</code>,
          <code>undefined</code>, <code>null</code>) и литералов (<code
            >{function(...): ...}</code
          >
          и <code>{{foo: string...}}</code>) всегда ненулевые по умолчанию.
          Используйте модификатор <code>?</code>, чтобы сделать его нулевым, но
          опускайте ненужный <code>!</code>.
        </li>

        <li>
          Ссылочные типы (обычно все, что угодно в
          <code>ВверхнемВерблюжьемСтиле</code>, включая
          <code>some.namespace.ReferenceType</code>) относятся к классу,
          перечислению, записи или typedef, определенному в другом месте. Так
          как эти типы могут быть или не быть нулевыми, невозможно определить по
          одному только имени, является ли оно нулевым или нет. Всегда
          используйте явные модификаторы <code>?</code> и <code>!</code> для
          этих типов, чтобы предотвратить двусмысленность при использовании в
          конкретных местах.
        </li>
      </ol>

      <p>Плохо:</p>

      <pre><code class="language-js prettyprint badcode">const /** MyObject */ myObject = null; // Непримитивные типы должны быть аннотированы.
const /** !number */ someNum = 5; // Примитивы по умолчанию не могут быть нулевыми.
const /** number? */ someNullableNum = null; // ? должно предшествовать типу.
const /** !{foo: string, bar: number} */ record = ...; // Всегда ненулевой.
const /** MyTypeDef */ def = ...; // Не ясно, что MyTypeDef нулевой.

// Не уверен, что объект (может быть нулевым), перечисление (ненулевой, если не указано иначе)
// или typedef (зависит от определения).
const /** SomeCamelCaseName */ n = ...;
</code></pre>

      <p>Хорошо:</p>

      <pre><code class="language-js prettyprint">const /** ?MyObject */ myObject = null;
const /** number */ someNum = 5;
const /** ?number */ someNullableNum = null;
const /** {foo: string, bar: number} */ record = ...;
const /** !MyTypeDef */ def = ...;
const /** ?SomeCamelCaseName */ n = ...;
</code></pre>

      <h4 id="jsdoc-type-casts">7.10.2 Преобразования типов</h4>

      <p>
        В случаях, когда компилятор неточно определяет тип выражения, а функции
        утверждения в
        <a href="https://google.github.io/closure-library/api/goog.asserts.html"
          >goog.asserts</a
        >
        не могут это исправить, можно уточнить тип, добавив комментарий к
        аннотации типа и заключив выражение в круглые скобки. Обратите внимание,
        что скобки необходимы.
      </p>

      <pre><code class="language-js prettyprint">/** @type {number} */ (x)</code></pre>

      <h4 id="jsdoc-template-parameter-types">
        7.10.3 Типы параметров шаблона
      </h4>

      <p>
        Всегда указывайте параметры шаблона. Таким образом, компилятор может
        сделать работу лучше, и читателю будет легче понять, что делает код.
      </p>

      <p>Плохо:</p>

      <pre><code class="language-js prettyprint badcode">const /** !Object */ users = {};
const /** !Array */ books = [];
const /** !Promise */ response = ...;
</code></pre>

      <p>Хорошо:</p>

      <pre><code class="language-js prettyprint">const /** !Object&lt;string, !User&gt; */ users = {};
const /** !Array&lt;string&gt; */ books = [];
const /** !Promise&lt;!Response&gt; */ response = ...;

const /** !Promise&lt;undefined&gt; */ thisPromiseReturnsNothingButParameterIsStillUseful = ...;
const /** !Object&lt;string, *&gt; */ mapOfEverything = {};
</code></pre>

      <p>Случаи, когда параметры шаблона не должны использоваться:</p>

      <ul>
        <li>
          <code>Object</code> используется для иерархии типов, а не структура
          подобная Map.
        </li>
      </ul>

      <h4 id="jsdoc-function-types">7.10.4 Функциональные выражения</h4>

      <p>
        <strong>Терминологическое уточнение</strong>:
        <em>функциональные выражения</em> относятся к аннотации типов функций с
        ключевым словом <code>function</code> в аннотации (см. примеры ниже).
      </p>

      <p>
        Там, где дано определение функции, не используйте функциональные
        выражения. Указывайте типы параметров и возвращаемых функций с помощью
        <code>@param</code> и <code>@return</code>, либо со строчными
        аннотациями (см. <a href="#jsdoc-method-and-function-comments">??</a>).
        Это включает анонимные функции и функции, определенные и назначенные в
        <code>const</code> (где функция jsdoc появляется над всем выражением
        назначения).
      </p>

      <p>
        Функциональные выражения необходимы, например, внутри
        <code>@typedef</code>, <code>@param</code> или <code>@return</code>.
        Используйте его также для переменных или свойств типа функции, если они
        не инициализируются сразу с определением функции.
      </p>

      <pre><code class="language-js prettyprint">  /** @private {function(string): string} */
  this.idGenerator_ = googFunctions.identity;
</code></pre>

      <p>
        При использовании функционального выражения всегда указывайте тип
        возврата явно. В противном случае типом возврата по умолчанию является
        <q>undefined</q> (<code>?</code>), что приводит к странному и
        неожиданному поведению и редко является тем, что действительно
        желательно.
      </p>

      <p>Плохо — ошибка типа, но предупреждение не выдается:</p>

      <pre><code class="language-js prettyprint badcode">/** @param {function()} generateNumber */
function foo(generateNumber) {
  const /** number */ x = generateNumber();  // Здесь нет ошибки типа времени компиляции.
}

foo(() =&gt; 'точно не число');
</code></pre>

      <p>Хорошо:</p>

      <pre><code class="language-js prettyprint">/**
 * @param {function(): *} inputFunction1 Может вернуть любой тип.
 * @param {function(): undefined} inputFunction2 Точно ничего не
 *      возвращает.
 * Внимание: тип возвращаемого значения `foo` подразумевает {undefined}.
 */
function foo(inputFunction1, inputFunction2) {...}
</code></pre>

      <h4 id="jsdoc-whitespace">7.10.5 Пробел</h4>

      <p>
        В пределах аннотации типа, после каждой запятой или двоеточия требуется
        один пробел или разрыв строки. Дополнительные разрывы строк могут быть
        вставлены для улучшения читабельности или во избежание превышения лимита
        в 80 символов. Эти разрывы должны быть выбраны и снабжены отступами в
        соответствии с рекомендациями (например,
        <a href="#formatting-line-wrapping">??</a> и
        <a href="#formatting-block-indentation">??</a>). Никакие другие
        пробельные символы не допускаются в аннотациях типов.
      </p>

      <p>Хорошо:</p>

      <pre><code class="language-js prettyprint">/** @type {function(string): number} */

/** @type {{foo: number, bar: number}} */

/** @type {number|string} */

/** @type {!Object&lt;string, string&gt;} */

/** @type {function(this: Object&lt;string, string&gt;, number): string} */

/**
 * @type {function(
 *     !SuperDuperReallyReallyLongTypedefThatForcesTheLineBreak,
 *     !OtherVeryLongTypedef): string}
 */

/**
 * @type {!SuperDuperReallyReallyLongTypedefThatForcesTheLineBreak|
 *     !OtherVeryLongTypedef}
 */
</code></pre>

      <p>Плохо:</p>

      <pre><code class="language-js prettyprint badcode">// Пробел должен быть только после двоеточия
/** @type {function(string) : number} */

// Поставьте пробелы после двоеточий и запятых
/** @type {{foo:number,bar:number}} */

// Не должно быть пробелов в объединениях типов
/** @type {number | string} */
</code></pre>

      <h3 id="jsdoc-visibility-annotations">7.11 Аннотации видимости</h3>

      <p>
        Аннотации видимости (<code>@private</code>, <code>@package</code>,
        <code>@protected</code>) могут быть указаны в
        <code>@fileoverview </code> или на любом экспортированном символе или
        свойстве. Не указывайте видимость для локальных переменных, будь то
        внутри функции или на верхнем уровне модуля. Все имена
        <code>@private</code> должны заканчиваться подчеркиванием.
      </p>

      <h2 id="policies">8 Политика</h2>

      <h3 id="policies-be-consistent">
        8.1 С проблемами, не указанными в Google Style: Будьте последовательны!
      </h3>

      <p>
        Для любого стилевого вопроса, который окончательно не решен этой
        спецификацией, предпочитайте делать то, что уже делает другой код в том
        же файле. Если это не решает вопрос, посмотрите файлы в этом же
        пакете.
      </p>

      <h3 id="policies-compiler-warnings">8.2 Предупреждения компилятора</h3>

      <h4 id="policies-use-a-standard-warning-set">
        8.2.1 Используйте стандартный набор предупреждений
      </h4>

      <p>
        Насколько это возможно, проекты должны использовать
        <code>--warning_level=VERBOSE</code>.
      </p>

      <h4 id="policies-how-to-handle-a-warning">
        8.2.2 Как работать с предупреждениями
      </h4>

      <p>
        Прежде чем что-либо делать, убедитесь, что вы точно понимаете, о чем
        говорит предупреждение. Если вы не уверены, почему предупреждение
        появляется, обратитесь за помощью.
      </p>

      <p>
        После того, как вы увидели предупреждение, попробуйте следующие шаги:
      </p>

      <ol>
        <li>
          <strong>Исправьте его или временно поправьте.</strong>
          Сделайте попытку полностью устранить предупреждение или найдите другой
          способ решить проблему, который позволит полностью избежать предупреждения.
        </li>

        <li>
          <strong
            >В другом случае, определите, не ложная ли это тревога.</strong
          >
          Если вы убеждены, что предупреждение недействительно, а код на самом
          деле безопасен и корректен, добавьте комментарий, чтобы убедить
          читателя в этом и примените аннотацию <code>@suppress</code>.
        </li>

        <li>
          <strong>Иначе, оставьте TODO комментарий.</strong> Это
          последнее средство. Если вы делаете это, не подавляйте
          предупреждение. Предупреждение должно быть видимым до тех пор, пока
          оно не будет должным образом исправлено.
        </li>
      </ol>

      <h4 id="policies-suppress-a-warning-at-the-narrowest-reasonable-scope">
        8.2.3 Подавляйте предупреждения в самом узком диапазоне
      </h4>

      <p>
        Предупреждения подавляются в самом узком разумном диапазоне, обычно это
        касается одной локальной переменной или очень маленького метода. Часто
        переменная или метод по этой причине выносятся отдельно.
      </p>

      <p>Пример</p>

      <pre><code class="language-js prettyprint">/** @suppress {uselessCode} Нераспознанная декларация 'use asm' */
function fn() {
  'use asm';
  return 0;
}
</code></pre>

      <p>
        Даже большое количество подавлений в классе все равно лучше, чем
        подавлять одно предупреждение во всем классе.
      </p>

      <h3 id="policies-deprecation">8.3 Устаревание</h3>

      <p>
        Пометьте устаревшие методы, классы или интерфейсы аннотациями
        <code>@deprecated</code>. Комментарий к устаревшим методам должен
        содержать простые и понятные указания по исправлению для других людей.
      </p>

      <h3 id="policies-code-not-in-google-style">
        8.4 Код не в Google Style
      </h3>

      <p>
        Иногда в вашей кодовой базе встречаются файлы, которые не соответствуют
        стилю Google. Возможно, они появились в результате приобретения или были
        написаны до того, как Google Style занял позицию по какой-то проблеме,
        или могут быть в не-Google Style по любой другой причине.
      </p>

      <h4 id="policies-reformatting-existing-code">
        8.4.1 Переформатируйте существующий код
      </h4>

      <p>
        При обновлении стиля существующего кода, следуйте данным рекомендациям:
      </p>

      <ol>
        <li>
          Необязательно изменять весь существующий код в соответствии с текущими
          рекомендациями по стилю. Переформатирование существующего кода
          является компромиссом между существованием старого формата и нового
          (code churn). Правила стиля меняются с течением времени, и такого рода
          подстройки для поддержания соответствия создают ненужные изменения.
          Однако, если в файл вносятся новые изменения, он должен быть в Google Style.
        </li>

        <li>
          Будьте осторожны, чтобы не допустить, чтобы исправление кода на новый
          стиль мешало фокусироваться на основном коде. Если вы обнаружили, что
          вносите много изменений в стиль, которые не являются критичными,
          делайте эти изменения в отдельных файлах или участках кода.
        </li>
      </ol>

      <h4 id="policies-newly-added-code-use-google-style">
        8.4.2 Новый добавленный код: используйте Google Style
      </h4>

      <p>
        В новых файлах используется Google Style, независимо от стиля в
        других файлах в том же пакете.
      </p>

      <p>
        При добавлении нового кода в файл, которые не поддерживает Google Style,
        рекомендуется сначала переформатировать существующий код с учетом
        рекомендации в <a href="#policies-reformatting-existing-code">??</a>.
      </p>

      <p>
        Если нет возможности выполнить это переформатирование, то новый код
        должен быть максимально согласован с существующим кодом в том же файле,
        но не должен нарушать руководство по стилю.
      </p>

      <h3 id="policies-local-style-rules">8.5 Локальные правила стиля</h3>

      <p>
        Группы и проекты могут принимать дополнительные правила в отношении
        стиля, помимо правил, содержащихся в настоящем документе, но они должны
        согласоваться с описанными в этом документе. Остерегайтесь чрезмерного
        количества правил, которые не служат никакой цели. Руководство по стилю
        не стремится определять стиль во всех возможных сценариях, и вы тоже не
        должны этого делать.
      </p>

      <h3 id="policies-generated-code-mostly-exempt">
        8.6 Сгенерированный код: в основном без правил
      </h3>

      <p>
        Исходный код, генерируемый в процессе сборки, не обязательно должен быть
        в Google Style. Однако, любые сгенерированные идентификаторы, на которые
        будут ссылаться из написанного от руки исходного кода, должны
        соответствовать требованиям к именованию. В качестве особого исключения, 
        такие идентификаторы могут содержать подчеркивания, что может помочь
        избежать конфликтов с написанными от руки идентификаторами.
      </p>

      <h2 id="appendices">9 Приложения</h2>

      <h3 id="appendices-jsdoc-tag-reference">9.1 Ссылки на теги JSDoc</h3>
      <p>
        JSDoc служит нескольким целям в JavaScript. Помимо того, что он
        используется для создания документации, он также используется для
        управления инструментарием. Наиболее известными являются аннотации типа
        Closure Compiler.
      </p>

      <h4 id="appendices-type-annotations">
        9.1.1 Аннотации типа и другие Closure Compiler аннотации
      </h4>

      <p>
        Документация для JSDoc, используемая компилятором, описана в
        <a
          href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler"
          >Аннотирование JavaScript для Closure Compiler</a
        >
        и
        <a
          href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System"
          >Типы в системе типов Closure</a
        >.
      </p>

      <h4 id="appendices-documentation-annotations">
        9.1.2 Документирующие аннотации
      </h4>

      <p>
        В дополнение к JSDoc, описанному в
        <a
          href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler"
          >Аннотирование JavaScript для Closure Compiler</a
        >
        следующие теги являются общими и хорошо поддерживаются различными
        инструментами генерации документации (такими как
        <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) для чисто
        документационных целей.
      </p>

      <p>
        Вы также можете увидеть другие типы аннотаций JSDoc в коде сторонних
        разработчиков. Эти аннотации отображаются в виде
        <a href="http://code.google.com/p/jsdoc-toolkit/wiki/TagReference"
          >Ссылка на теги JSDoc Toolkit</a
        >, но не считаются частью текущего стиля Google.
      </p>

      <section class="zippy">
        <h5>
          9.1.2.1 <code>@author</code> or <code>@owner</code> -
          <em>Не рекомендуется.</em>
        </h5>

        <p><strong>Не рекомендуется.</strong></p>

        <p>Синтаксис: <code>@author username@google.com (First Last)</code>.</p>

        <pre><code class="language-js prettyprint">/**
 * @fileoverview Утилиты для работы с текстами.
 * @author kuth@google.com (Uthur Pendragon)
 */
</code></pre>

        <p>
          Документирование автора файла или владельца тестов обычно
          используются только в комментарии <code>@fileoverview</code>. Тэг
          <code>@owner </code> используется инструментальной панелью модульного
          теста для определения того, кому принадлежат результаты тестов.
        </p>
      </section>

      <section class="zippy">
        <h5>9.1.2.2 <code>@bug</code></h5>

        <p>Синтаксис: <code>@bug номер бага</code>.</p>

        <pre><code class="language-js prettyprint">/** @bug 1234567 */
function testSomething() {
  // &#8230;
}

/**
 * @bug 1234568
 * @bug 1234569
 */
function testTwoBugs() {
  // &#8230;
}
</code></pre>

        <p>
          Показывает, какие есть ошибки в тестах данной функции.
        </p>

        <p>
          Если ошибок несколько, они должны иметь свою строку <code>@bug</code>, чтобы
          поиск регрессионных тестов был максимально простым.
        </p>
      </section>

      <section class="zippy">
        <h5>9.1.2.3 <code>@code</code> — <em>Устарело. Не используйте.</em></h5>

        <p>
          <strong
            >Устарело. Не используйте. Вместо этого используйте обратные ссылки
            Markdown.</strong
          >
        </p>

        <p>Синтаксис: <code>{@code ...}</code></p>

        <p>
          Исторически <code>`BatchItem`</code> был написан как
          <code class="badcode">{@code BatchItem}</code>.
        </p>

        <pre><code class="language-js prettyprint">/** Обработка ожидаемого экземпляра `BatchItem`. */
function processBatchItems() {}
</code></pre>

        <p>
          Указывает, что термин в описании JSDoc является кодом, поэтому он
          может быть корректно отформатирован в сгенерированной документации.
        </p>
      </section>

      <section class="zippy">
        <h5>9.1.2.4 <code>@desc</code></h5>

        <p>Синтаксис: <code>@desc сообщения</code>.</p>

        <pre><code class="language-js prettyprint">/** @desc Уведомление пользователя о том, что его учетная запись была создана. */
exports.MSG_ACCOUNT_CREATED = goog.getMsg(
    'Ваша учетная запись была успешно создана.');
</code></pre>
      </section>
      <section class="zippy">
        <h5>9.1.2.5 <code>@link</code></h5>

        <p>Синтаксис: <code>{@link ...}</code></p>

        <p>
          Этот тег используется для создания перекрестных ссылок в создаваемой
          документации.
        </p>

        <pre><code class="language-js prettyprint">/** Обработка ожидаемого экземпляра {@link BatchItem}. */
function processBatchItems() {}
</code></pre>

        <p>
          <strong>Историческое примечание:</strong> @link теги также
          используются для создания внешних ссылок в генерируемой документации.
          Для внешних ссылок всегда используйте синтаксис ссылки Markdown:
        </p>

        <pre><code class="language-js prettyprint">/**
 * Этот класс реализует полезное подмножество
 * [нативных интерфейсов Event](https://dom.spec.whatwg.org/#event).
 */
class ApplicationEvent {}
</code></pre>
      </section>

      <section class="zippy">
        <h5>9.1.2.6 <code>@see</code></h5>

        <p>Синтаксис: <code>@see Link</code>.</p>

        <pre><code class="language-js prettyprint">/**
 * Добавляет один элемент в небезопасном режиме.
 * @see #addSafely
 * @see goog.Collect
 * @see goog.RecklessAdder#add
 */
</code></pre>

        <p>Ссылка на поиск другой функции или метода класса.</p>
      </section>

      <section class="zippy">
        <h5>9.1.2.7 <code>@supported Описание</code></h5>

        <p>Синтаксис: <code>@supported Описание</code>.</p>

        <pre><code class="language-js prettyprint">/**
 * @fileoverview Event Manager
 * Предоставляет абстрактный интерфейс к системам событий браузеров.
 * @supported IE10+, Chrome, Safari
 */
</code></pre>

        <p>
          Используется в описании файла для указания того, какие браузеры
          поддерживаются файлом.
        </p>
      </section>

      <h4 id="appendices-framework-specific-annotations">
        9.1.3 Специальные аннотации для фреймворков
      </h4>

      <p>Следующие аннотации относятся к конкретному фреймворку.</p>

      <section class="zippy">
        <h5>9.1.3.1 <code>@ngInject</code> for Angular 1</h5>
      </section>

      <section class="zippy">
        <h5>9.1.3.2 <code>@polymerBehavior</code> for Polymer</h5>

        <p>
          <a href="https://github.com/google/closure-compiler/wiki/Polymer-Pass"
            >https://github.com/google/closure-compiler/wiki/Polymer-Pass</a
          >.
        </p>
      </section>

      <section class="zippy"></section>

      <h4 id="appendices-notes-about-standard-closure-compiler-annotations">
        9.1.4 Примечания к стандартным аннотациям Closure Compiler
      </h4>

      <p>Раньше следующие теги были стандартными, но теперь они устарели.</p>

      <section class="zippy">
        <h5>
          9.1.4.1 <code>@expose</code> — <em>Устарел. Не используйте.</em>
        </h5>

        <p>
          <strong
            >Устарел. Не используйте. Используйте вместо этого
            <code>@export </code> и/или <code>@nocollapse</code>.</strong
          >
        </p>
      </section>

      <section class="zippy">
        <h5>
          9.1.4.2 <code>@inheritDoc</code> — <em>Устарел. Не используйте.</em>
        </h5>

        <p>
          <strong
            >Устарел. Не используйте. Используйте вместо этого
            <code>@override</code></strong
          >.
        </p>
      </section>

      <section class="zippy"></section>

      <h3 id="appendices-commonly-misunderstood-style-rules">
        9.2 Правила стиля, вызывающие недопонимание
      </h3>

      <p>
        Вот коллекция менее известных или часто непонятных фактов о Google Style
        для JavaScript. (Следующие утверждения верны; причем эти случаи не выдуманы).
      </p>

      <ul>
        <li>
          Ни заявление об авторских правах, ни <code>@author</code> не требуется
          в исходном файле. (Также явно не рекомендуется)
        </li>

        <li>
          Не существует однозначного и точного правила, регулирующего порядок членов
          класса (<a href="#features-classes">??</a>).
        </li>
        <li>
          Пустые блоки обычно могут быть представлены кратко как
          <code>{}</code>, как подробно описано в (<a
            href="#formatting-empty-blocks"
            >??</a
          >).
        </li>

        <li>
          Главным указанием для переноса строк является: предпочтительнее
          переносить строки на более высоком синтаксическом уровне (<a
            href="#formatting-where-to-break"
            >??</a
          >).
        </li>

        <li>
          Допускаются не-ASCII-символы в строковых литералах, комментариях и
          JSDoc, и фактически рекомендуется, когда они делают код более легким
          для чтения, чем эквивалентный Unicode с экранированием (<a
            href="#non-ascii-characters"
            >??</a
          >).
        </li>
      </ul>

      <h3 id="appendices-style-related-tools">
        9.3 Инструменты, связанные со стилем
      </h3>

      <p>
        Для поддержки различных аспектов Google Style существуют следующие
        инструменты.
      </p>

      <h4 id="appendices-tools-closure-compiler">9.3.1 Closure Compiler</h4>

      <p>
        Эта программа выполняет проверку типа и другие проверки, оптимизации и
        другие преобразования (такие, как даунгрейд кода с ECMAScript 6 на
        ECMAScript 5).
      </p>

      <h4 id="appendices-clang-format">9.3.2 <code>clang-format</code></h4>

      <p>
        Данная программа переформатирует исходный код JavaScript в Google Style,
        а также применяет ряд необязательных, но часто повышающих читабельность практик
        форматирования. Вывод, полученный с помощью <code>clang-format</code>,
        соответствует руководству по стилю.
      </p>

      <p>
        <code>clang-format</code> не является обязательным. Авторам разрешено изменять его
        вывод, а рецензентам — запрашивать вносить дополнения; споры разрешаются
        обычным образом. Также могут приниматься решения о локальном внедрении
        новых изменений.
      </p>

      <h4 id="appendices-closure-compiler-linter">
        9.3.3 Линтер Closure Compiler
      </h4>

      <p>
        Данная программа проверяет на наличие различных ошибок и антишаблонов.
      </p>

      <h4 id="appendices-conformance-framework">9.3.4 Фреймворк Conformance</h4>

      <p>
        JS Conformance Framework — это инструмент, входящий в состав Closure
        Compiler, который предоставляет разработчикам простое средство для
        задания набора дополнительных проверок, которые будут выполняться в их
        коде перед стандартными проверками. Проверки на соответствие могут,
        например, запретить доступ к определенному свойству, вызов определенной
        функции или недостающую информацию о типе.
      </p>

      <p>
        Эти правила обычно используются для обеспечения соблюдения критических
        ограничений (таких, как определение глобальных объектов, которые могут
        нарушить код проекта) и шаблонов безопасности (таких, как использование
        <code>eval</code> или присвоение <code>innerHTML</code>), или более
        простых для улучшения качества кода.
      </p>

      <p>
        Для получения дополнительной информации обратитесь к официальной
        документации
        <a
          href="https://github.com/google/closure-compiler/wiki/JS-Conformance-Framework"
          >JS Conformance Framework</a
        >.
      </p>

      <h3 id="appendices-legacy-exceptions">
        9.4 Исключение устаревших платформ
      </h3>

      <h4 id="appendices-legacy-exceptions-overview">9.4.1 Описание</h4>

      <p>
        В этом разделе описаны исключения и дополнительные правила, которым
        необходимо следовать, когда современный синтаксис ECMAScript 6
        недоступен авторам кода. Исключения из рекомендуемого стиля необходимы в
        тех случаях, когда синтаксис ECMAScript 6 недоступен:
      </p>

      <ul>
        <li>Использование декларации <code>var</code> допустимо</li>
        <li>Использование декларации <code>arguments</code> допустимо</li>
        <li>Опциональные параметры без стандартных значений допустимы</li>
      </ul>

      <h4 id="appendices-legacy-exceptions-var">
        9.4.2 Использование <code>var</code>
      </h4>

      <h5 id="appendices-legacy-exceptions-var-scope">
        9.4.2.1 <code>var</code> имеет не блочную область видимости
      </h5>

      <p>
        <code>var</code> декларации распространяются с начала функции, скрипта или модуля, что может привести к неожиданному
        поведению, особенно при замыкании функций, которые ссылаются на
        <code>var</code> декларации внутри циклов. См. следующий пример:
      </p>

      <pre><code class="language-js prettyprint badcode">for (var i = 0; i &lt; 3; ++i) {
  var iteration = i;
  setTimeout(function() { console.log(iteration); }, i*1000);
}

// лог 2, 2, 2 -- а не 0, 1, 2
// потому что `iteration` имеет область видимости в пределах функции, а не локально для цикла.

</code></pre>

      <h5 id="appendices-legacy-exceptions-var-declare">
        9.4.2.2 Объявляйте переменные как можно ближе к месту первого использования
      </h5>

      <p>
        Несмотря на то, что <code>var</code> объявления имеют область видимости
        в пределах всей функции, для удобочитаемости <code>var</code> объявления
        должны быть как можно ближе к месту их первого использования. Однако не
        помещайте декларацию <code>var</code> внутри блока, если на эту
        переменную есть ссылка за пределами блока. Например:
      </p>

      <pre><code class="language-js prettyprint">function sillyFunction() {
  var count = 0;
  for (var x in y) {
    // "count" может быть объявлена здесь, но не делайте так
    count++;
  }
  console.log(count + ' элементов в y');
}
</code></pre>

      <h5 id="appendices-legacy-exceptions-var-const">
        9.4.2.3 Использование @const для константных значений
      </h5>

      <p>
        В глобальных определениях, в которых может использоваться ключевое слово
        <code>const</code>, если оно доступно — используйте его вместо
        <code>var</code>. Это опционально для локальных переменных.
      </p>

      <h4 id="appendices-legacy-exceptions-function">
        9.4.3 Не используйте объявления функций с видимостью в пределах блока
      </h4>

      <p><strong>Не</strong> делайте так:</p>

      <pre><code class="language-js prettyprint badcode">if (x) {
  function foo() {}
}
</code></pre>

      <p>
        Хотя большинство виртуальных машин на JavaScript, реализованных до
        ECMAScript 6, поддерживают функциональные декларации внутри блоков, они
        не были стандартизированы. Введения были несовместимы друг с другом и
        теперь также со стандартным поведением ECMAScript 6 при объявлении функций в
        блоках. ECMAScript 5 и ранее допускал только объявления функций в списке
        корневых операторов скрипта или функции и явно запрещал их в блочных
        диапазонах в строгом режиме.
      </p>

      <p>
        Чтобы получить согласованное поведение, вместо этого используйте
        <code>var</code>, инициализированный выражением функции, для определения
        функции внутри блока:
      </p>

      <pre><code class="language-js prettyprint">if (x) {
  var foo = function() {};
}
</code></pre>

      <h4 id="appendices-legacy-exceptions-goog-provide">
        9.4.4 Управление зависимостями при помощи
        <code>goog.provide</code>/<code>goog.require</code>
      </h4>

      <h5 id="appendices-legacy-exceptions-goog-provide-summary">
        9.4.4.1 Резюме
      </h5>

      <p>
        <strong
          >Предупреждение: управление зависимостями с помощью
          <code>goog.provide</code> устарело.</strong
        >
        Все новые файлы, даже в проектах, использующих
        <code>goog.provide</code> для старых файлов, должны использовать
        <a href="#source-file-structure"><code>goog.module</code></a
        >. Следующие правила предназначены только для уже существующих
        <code>goog.provide</code> файлов.
      </p>

      <ul>
        <li>
          Размещайте все <code>goog.provide</code> в самом начале файла, после -
          <code>goog.require</code>
          . Разделяйте provide от require с помощью пустой линии.
        </li>
        <li>
          Сортируйте записи в алфавитном порядке (сначала заглавными буквами).
        </li>
        <li>
          Не переносите оператор <code>goog.provide</code> и
          <code>goog.require</code>. Превышайте лимит в 80 символов.
        </li>
        <li>Используйте только provide для символов высшего порядка.</li>
      </ul>

      <p>
        <code>goog.provide</code> операторы должны быть сгруппированы и помещены
        первыми. Все утверждения <code>goog.require</code> должны следовать за
        ними. Оба списка должны быть разделены пустой строкой.
      </p>

      <p>
        Как и при импорте операторов в других языках, операторы
        <code>goog.provide</code> и <code>goog.require</code> должны быть
        написаны в одной строке, даже если они превышают ограничение длины
        строки в 80 символов.
      </p>

      <p>
        Строки должны быть отсортированы в алфавитном порядке, начиная с заглавных
        букв:
      </p>

      <pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');
goog.provide('namespace.helperFoo');

goog.require('an.extremelyLongNamespace.thatSomeoneThought.wouldBeNice.andNowItIsLonger.Than80Columns');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.dominoes');

</code></pre>

      <p>
        Все члены, определенные в классе, должны быть в одном файле. В файле,
        содержащем несколько членов, определенных в одном и том же классе
        (например, перечисления, внутренние классы и т.д.), должны быть
        представлены только классы верхнего уровня.
      </p>

      <p>Делайте так:</p>

      <pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');</code></pre>

      <p>А не:</p>

      <pre><code class="language-js prettyprint badcode">goog.provide('namespace.MyClass');
goog.provide('namespace.MyClass.CONSTANT');
goog.provide('namespace.MyClass.Enum');
goog.provide('namespace.MyClass.InnerClass');
goog.provide('namespace.MyClass.TypeDef');
goog.provide('namespace.MyClass.staticMethod');
</code></pre>

      <p>Могут также предоставляться (provide) члены в пространствах имен:</p>

      <pre><code class="language-js prettyprint">goog.provide('foo.bar');
goog.provide('foo.bar.CONSTANT');
goog.provide('foo.bar.method');
</code></pre>

      <h5 id="appendices-legacy-exceptions-goog-scope">
        9.4.4.2 Использование псевдонимов с <code>goog.scope</code>
      </h5>

      <p>
        <strong>Предупреждение: <code>goog.scope</code> устарел.</strong>
        Новые файлы не должны использовать <code>goog.scope</code> даже в
        проектах с существующим использованием <code>goog.scope</code>.
      </p>

      <p>
        <code>goog.scope</code> может быть использован для сокращения ссылок на
        символы, расположенных в пространстве имен кода с использованием
        управления зависимостями при помощи
        <code>goog.provide</code>/<code>goog.require</code>.
      </p>

      <p>
        В каждый файл может быть добавлен только один вызов
        <code>goog.scope</code>. Всегда помещайте его в глобальную область
        видимости.
      </p>

      <p>
        Вызову <code>goog.scope(function()) {</code> должна предшествовать ровно
        одна пустая строка и следовать после операторов 
        <code>goog.provide</code>, <code>goog.require</code> или комментариев
        верхнего уровня. Вызов должен быть закрыт в последней строке файла.
        Добавьте <code>// goog.scope</code> к закрывающему выражению области
        видимости. Отделите комментарий от точки с запятой двумя пробелами.
      </p>

      <p>
        Аналогично пространствам имен в C++, не отступайте под объявлениями
        <code>goog.scope</code>. Вместо этого продолжайте без отступа.
      </p>

      <p>
        Используйте псевдонимы только для имен, которые не будут переназначены
        другому объекту (например, большинство конструкторов, перечислений и
        пространств имен). Не делайте так (см. ниже, как создать псевдоним для
        конструктора):
      </p>

      <pre><code class="language-js prettyprint badcode">goog.scope(function() {
var Button = goog.ui.Button;

Button = function() { ... };
...
</code></pre>

      <p>
        Имена должны быть такими же, как и последнее свойство глобального
        объекта, на который они накладывают псевдонимы.
      </p>

      <pre><code class="language-js prettyprint">goog.provide('my.module.SomeType');

goog.require('goog.dom');
goog.require('goog.ui.Button');

goog.scope(function() {
var Button = goog.ui.Button;
var dom = goog.dom;

// Псевдоним нового типа после декларации конструктора.
my.module.SomeType = function() { ... };
var SomeType = my.module.SomeType;

// Объявляйте методы в прототипе, как обычно:
SomeType.prototype.findButton = function() {
  // Кнопка с псевдонимом как выше.
  this.button = new Button(dom.getElement('my-button'));
};
...
});  // goog.scope
</code></pre>

      <h5 id="appendices-legacy-exceptions-forward-declare">
        9.4.4.3 <code>goog.forwardDeclare</code>
      </h5>

      <p>
        Предпочтительно использовать <code>goog.requireType</code> вместо
        <code>goog.forwardDeclare</code> для разрыва циклических зависимостей между
        файлами в одной и той же библиотеке. В отличие от
        <code>goog.require</code>, оператор
        <code>goog.requireType</code> позволяет импортировать пространство имен
        до его определения.
      </p>

      <p>
        <code>goog.forwardDeclare</code> может по-прежнему использоваться в
        старом коде для разрыва циклических ссылок, выходящих за границы
        библиотеки, но более новый код должен быть структурирован, чтобы
        избежать этого.
      </p>

      <p>
        Оператор <code>goog.forwardDeclare</code> должен следовать тем же
        правилам стиля, что и <code>goog.require</code> и
        <code>goog.requireType</code>. Весь блок
        <code>goog.forwardDeclare</code>, <code>goog.require</code> и
        <code>goog.requireType</code> операторов должен сортироваться в
        алфавитном порядке.
      </p>
    </div>
  </body>
</html>
